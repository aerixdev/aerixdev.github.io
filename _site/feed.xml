<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2022-09-17T01:49:08+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">에어릭스 환경시스템사업부 기술블로그</title><subtitle>IT기업이 아닌 에어릭스에서 살아가고 있는 개발자들</subtitle><author><name>(주)에어릭스</name></author><entry><title type="html">mosquitto에 설정정보 변경 반영하기</title><link href="http://localhost:4000/2022/09/16/mosquitto-hupsignal.html" rel="alternate" type="text/html" title="mosquitto에 설정정보 변경 반영하기" /><published>2022-09-16T00:00:00+09:00</published><updated>2022-09-16T00:00:00+09:00</updated><id>http://localhost:4000/2022/09/16/mosquitto-hupsignal</id><content type="html" xml:base="http://localhost:4000/2022/09/16/mosquitto-hupsignal.html"><![CDATA[<p>mosquitto는 open source기반의 대표적인 MQTT Broker로 저희 에어릭스에서도 센서 데이터를 수집하는 용도로 사용하고 있습니다.</p>

<p>오늘은 mosquitto의 설정정보가 변경되었을 때, 서버를 직접 재시작시키지 않고 HUP signal을 전송하여 변경된 설정내용을 Reload하는 방법에 대해서 포스팅하려고 합니다.</p>

<p>의외로 방법은 간단합니다.</p>

<h2 id="hup-signal란">HUP signal란?</h2>

<p>리눅스 운영체제에서 HUP hangup의 약자로 프로세스를 재시작시키는 시그널을 의미합니다.</p>

<h2 id="mosquitto의-pid확인">mosquitto의 PID확인</h2>

<p>HUP signal을 mosquitto에 전송시켜서 설정정보를 Reload하게 하려면 mosquitto의 PID(프로세스 ID)를 먼저 확인해야 합니다.
mosquitto의 PID는 pid_file에 저장되어 있습니다. pid_file의 경로는 mosquitto.conf 파일을 열어서 확인할 수 있습니다.</p>

<p><strong>아래는 제가 테스트에 사용했던 mosquitto.conf파일의 내용입니다.</strong></p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code>pid_file /run/mosquitto/mosquitto.pid

persistence <span class="nb">true
</span>persistence_location /var/lib/mosquitto/

log_dest file /var/log/mosquitto/mosquitto.log

include_dir /etc/mosquitto/conf.d
</code></pre></div></div>

<p>파일의 내용을 보니 pid_file의 경로가 /run/mosquitto/mosquitto.pid로 지정되어 있는 것을 알 수 있었습니다. /run/mosquitto/mosquitto.pid 파일을 열어서
pid의 값을 확인하면 됩니다. 제가 테스트했던 환경에서는 PID가 2380으로 저장되어 있었습니다.</p>

<h2 id="hup-signal-발생">HUP signal 발생</h2>

<p>우분투 리눅스 기준으로 HUP Signal을 발생시키는 방법은 다음과 같습니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$sudo</span> <span class="nb">kill</span> <span class="nt">--signal</span> HUP <span class="o">[</span>PID]
</code></pre></div></div>

<p>제가 테스트했던 환경에서는 PID가 2380d이었기 떄문에 다음과 같이 명령을 실행시켜서 HUP signal을 발생시킬 수 있엇습니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">$sudo</span> <span class="nb">kill</span> <span class="nt">--signal</span> HUP 2380
</code></pre></div></div>

<p>mosquitto의 로그 파일을 열어보면 아래 그림처럼 Reloading config메시지가 출력된 것을 확인할 수 있습니다.</p>

<p><img src="/img/posts/mosquitto_log.png" alt="log" /></p>]]></content><author><name>이상훈</name></author><summary type="html"><![CDATA[mosquitto는 open source기반의 대표적인 MQTT Broker로 저희 에어릭스에서도 센서 데이터를 수집하는 용도로 사용하고 있습니다.]]></summary></entry><entry><title type="html">Broker 서버의 TPS 측정을 위한 JMeter Remote 구축기</title><link href="http://localhost:4000/2022/09/13/JMeter_remote.html" rel="alternate" type="text/html" title="Broker 서버의 TPS 측정을 위한 JMeter Remote 구축기" /><published>2022-09-13T00:00:00+09:00</published><updated>2022-09-13T00:00:00+09:00</updated><id>http://localhost:4000/2022/09/13/JMeter_remote</id><content type="html" xml:base="http://localhost:4000/2022/09/13/JMeter_remote.html"><![CDATA[<p>참조한 공식 문서 : <a href="https://jmeter.apache.org/usermanual/remote-test.html">https://jmeter.apache.org/usermanual/remote-test.html</a></p>

<h2 id="tps-측정-배경">TPS 측정 배경</h2>

<p>저희가 사용하고 있는 MQTT Broker 서버는 성능을 대략적으로만 파악하고 있는 상황이었습니다. 하지만 운용 단계에서는 생각보다 더 많은 부하가 걸리는 상황이 발생하기 때문에 서버가 최대로 처리할 수 있는 한계를 명확하게 파악하는 일이 필요했고 이를 경험이나 감에 맡기는 것은 바람직하지 않기 때문에 TPS(1초당 처리량)이라는 기준을 통해서 성능을 판단하는 방향으로 개선하기로 결정했기 때문입니다.</p>

<h2 id="tps의-측정-도구로-jmeter을-선정한-이유">TPS의 측정 도구로 JMeter을 선정한 이유</h2>

<ol>
  <li>
    <p>무료</p>

    <p>회사에서 사용하는 도구이기 때문에 라이센스는 중요한 문제입니다. JMeter의 경우 Apache 라이센스를 채택하여 공개된 오픈소스라는 장점이 있습니다.</p>
  </li>
  <li>
    <p>다양한 플러그인</p>

    <p>플러그인을 통해서 편의성을 높여주는 기능을 추가할 수 있으며 무엇보다도 MQTT 서버를 테스트하는 만큼 MQTT 프로토콜을 지원해야만 했고 JMeter의 경우 이를 MQTT 플러그인을 통하여 지원하고 있습니다.</p>
  </li>
  <li>
    <p>Remote를 통하여 부하 시스템을 구축할 수 있다.</p>

    <p>1개의 컴퓨터로 서버에 부하를 거는 것보다는 다수의 컴퓨터에 서버로 부하를 거는 것이 보다 더 정확하게 부하를 걸 수 있으며 JMeter는 Remote 기능을 통하여 이러한 시스템을 손쉽게 구축하는 것이 가능한 도구입니다.</p>
  </li>
</ol>

<h2 id="구축기">구축기</h2>

<p><img src="/img/posts/jmeter.png" alt="jmeter" /></p>

<h3 id="1-부하-서버로-사용될-컴퓨터들을-모으기">1. 부하 서버로 사용될 컴퓨터들을 모으기</h3>

<p>정확한 테스트를 위해서 부하를 거는 서버가 여러 대인 상황에서 제어 서버를 통해서 명령을 내려서 목적지의 서버에 부하를 거는 상황이 바람직하기 때문에 개발팀의 내부에서 사용하지 않는 컴퓨터를 모았습니다.</p>

<h3 id="2-사용될-jmeter-만들기">2. 사용될 JMeter 만들기</h3>

<p>마스터 서버(제어)와 슬레이브 서버(Remote)에서 JMeter은 동일한 자바 버전과 동일한 플러그인, 그리고 동일한 JMeter을 가져야 합니다. 이를 위해서 플러그인을 설치하여 커스텀한 JMeter을 만들고 이 JMeter을 각 서버에 배포하는 형태로 진행되었습니다.</p>

<h3 id="21-자바-버전의-확인">2.1. 자바 버전의 확인</h3>

<p>공식 문서에서 JMeter의 자바 버전은 제어 서버와 Remote 서버가 동일한 상황을 권장하고 있습니다. 자바 버전은 다음과 같은 명령어로 확인할 수 있습니다.</p>

<div class="language-jsx highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//java 버전 확인</span>
<span class="nx">java</span> <span class="o">--</span><span class="nx">version</span>
</code></pre></div></div>

<h3 id="22-jmeter-플러그인의-설치-장소">2.2. JMeter 플러그인의 설치 장소</h3>

<p>기본적으로 플러그인의 설명에 나와있으나 보통은 JMeter 폴더의 /lib 또는 /lib/ext입니다.</p>

<h3 id="23-유용한-플러그인">2.3. 유용한 플러그인</h3>

<p>JMeter Plugins Manager : <a href="https://jmeter-plugins.org/wiki/PluginsManager/">https://jmeter-plugins.org/wiki/PluginsManager/</a></p>

<p>JMeter의 플러그인을 손쉽게 관리하고 추가할 수 있는 플러그인입니다.</p>

<p>Response Times Over Time: <a href="https://jmeter-plugins.org/wiki/ResponseTimesOverTime/">https://jmeter-plugins.org/?search=jpgc-graphs-basic</a></p>

<p>측정 결과를 그래프로 확인할 수 있는 플러그인입니다.</p>

<p>mqtt-jmeter : <a href="https://github.com/emqx/mqtt-jmeter">https://github.com/emqx/mqtt-jmeter</a></p>

<p>MQTT 프로토콜을 측정할 수 있는 플러그인입니다.</p>

<h3 id="3-jmeter-연동하기">3. JMeter 연동하기</h3>

<p>설정한 JMeter을 배포하고 슬레이브 서버들을 실행시킨 후에 연동하여 제어 서버에서 명령을 내리면 총 4대의 서버가 목적지 서버에 부하를 거는 시스템을 구성하였습니다.</p>

<h3 id="31-jmeter의-연동-및-실행방법">3.1. JMeter의 연동 및 실행방법</h3>

<p>마스터의 설정 파일을 수정하여 슬레이브들의 주소를 등록합니다. 포트 번호는 따로 설정하지 않으면 디폴트 값 1099로 설정됩니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>// ../bin/jmeter.properties
...
# Remote Hosts - comma delimited
remote_hosts=127.0.0.1,xxx.xx.xxx.xx,..
</code></pre></div></div>

<p>설정을 마친 후에 jmeter을 실행합니다. 이때 마스터와 슬레이브의 실행파일이 다르므로 주의해서 진행해야 합니다.  슬레이브들의 주소들이 정상적으로 등록된 경우에 실행 - 원격란에서 확인할 수 있습니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>//마스터
jmeter.bat (윈도우) / jmeter.sh (리눅스)

//슬레이브
jmeter-server.bat / jmeter-server(리눅스)
</code></pre></div></div>

<h3 id="32-linux-관련-문제">3.2. Linux 관련 문제</h3>

<p>linux의 경우 다음과 같은 메시지와 함께 정상적으로 실행되지 않는 문제가 있을 수 있습니다.</p>

<p>java.rmi.RemoteException: Cannot start. OO is a loopback address.</p>

<p>이러한 문제가 발생하는 경우 hostname을 기기의 IP 주소로 지정하여 실행시키는 방법으로 해결할 수 있습니다.</p>

<p>./jmeter-server -D java.rmi.server.hostname=IP 주소</p>

<h3 id="33-연동이-제대로-이루어지지-않는-경우">3.3. 연동이 제대로 이루어지지 않는 경우</h3>

<p>기본적으로 제어 포트에 해당하는 포트는 제어 서버와 슬레이브 서버 모두가 통신이 허용되어야만 합니다.</p>

<ol>
  <li>방화벽 해제(ubuntu 기준)</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ufw disable
</code></pre></div></div>

<ol>
  <li>포트 허용(ubuntu 기준)</li>
</ol>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ufw allow 1099
</code></pre></div></div>

<h3 id="34-ssl-문제">3.4 SSL 문제</h3>

<p>SSL 오류가 발생하는 경우 SSL을 아예 사용하지 않도록 jmeter.properties에 다음과 같이 설정하거나 SSL 설정 후 진행합니다.</p>

<h3 id="341-ssl-해제">3.4.1 SSL 해제</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>server.rmi.ssl.disable=true
</code></pre></div></div>

<h3 id="342-ssl-설정">3.4.2 SSL 설정</h3>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cd jmeter/bin
$ ./create-rmi-keystore.sh
What is your first and last name?
  [Unknown]:  rmi
What is the name of your organizational unit?
  [Unknown]:  My unit name
What is the name of your organization?
  [Unknown]:  My organisation name
What is the name of your City or Locality?
  [Unknown]:  Your City
What is the name of your State or Province?
  [Unknown]:  Your State
What is the two-letter country code for this unit?
  [Unknown]:  XY
Is CN=rmi, OU=My unit name, O=My organisation name, L=Your City, ST=Your State, C=XY correct?
  [no]:  yes

Copy the generated rmi_keystore.jks to jmeter/bin folder or reference it in property 'server.rmi.ssl.keystore.file'
</code></pre></div></div>

<h3 id="4-테스트-계획-설정-및-테스트">4. 테스트 계획 설정 및 테스트</h3>

<p>구성된 시스템을 활용하여 목적지인 MQTT 서버의 테스트를 수행했습니다.</p>

<h3 id="41-jmeter의-사용법">4.1 JMeter의 사용법</h3>

<p>JMeter 실행 후 다음과 같은 같은 화면을 볼 수 있으며 테스트 계획을 설정한 후에 테스트할 수 있습니다. 여기에서는 간단한 예제로써 쓰레드 그룹을 만든 후에 간단한 HTTP Request 요청을 시도하겠습니다.</p>

<p><img src="/img/posts/jmeter_home.png" alt="" />
<img src="/img/posts/jmeter_thread.png" alt="" /></p>

<p>Number of Threads : 사용자 수</p>

<p>Ramp-up Period : 사용자가 모두 생성되는데 걸리는 시간(길수록 천천히 생성)</p>

<p>Loop Count : 반복 횟수</p>

<p>Infinite : 무한반복</p>

<p><img src="/img/posts/jmeter_http.png" alt="" />
<img src="/img/posts/jmeter_request.png" alt="" /></p>

<p>테스트 계획 설정이 끝났으면 다음과 같이 슬레이브에 테스트를 명령합니다.</p>

<p><img src="/img/posts/jmeter_remote.png" alt="" /></p>

<h3 id="5-실제-테스트-결과">5. 실제 테스트 결과</h3>

<p>사용하고 있는 Broker 서버에 100, 200, 400, 800, 1200개의 접속이 5분동안 발생하는 경우를 가정하여 테스트한 TPS 결과입니다.</p>

<p>100개의 접속을 가정한 경우
<img src="/img/posts/thingarx_100.png" alt="" />
200개의 접속을 가정한 경우
<img src="/img/posts/thingarx_200.png" alt="" />
400개의 접속을 가정한 경우
<img src="/img/posts/thingarx_400.png" alt="" />
800개의 접속을 가정한 경우
<img src="/img/posts/thingarx_800.png" alt="" />
1200개의 접속을 가정한 경우
<img src="/img/posts/thingarx_1200.png" alt="" /></p>

<h3 id="6-결론">6. 결론</h3>

<p>저희가 사용하고 있는 서버는 최대 800의 사용자가 동시에 접근하는 MQTT 접속을 처리할 수 있으며 TPS의 경우 1600~2800정도가 나온다는 것을 확인할 수 있었습니다. 또한 JMeter을 이용하여 구축함으로써 MQTT가 아닌 다른 프로토콜을 측정하는 것이 가능한 시스템을 만들 수 있었습니다.</p>]]></content><author><name>강민구,강민석</name></author><summary type="html"><![CDATA[참조한 공식 문서 : https://jmeter.apache.org/usermanual/remote-test.html]]></summary></entry><entry><title type="html">MQTT 서버 보안성 강화하기</title><link href="http://localhost:4000/2022/09/13/MQTT_security.html" rel="alternate" type="text/html" title="MQTT 서버 보안성 강화하기" /><published>2022-09-13T00:00:00+09:00</published><updated>2022-09-13T00:00:00+09:00</updated><id>http://localhost:4000/2022/09/13/MQTT_security</id><content type="html" xml:base="http://localhost:4000/2022/09/13/MQTT_security.html"><![CDATA[<p>안녕하세요? 에어릭스 환경시스템 사업부 개발팀장 이상훈입니다. 이번에는 MQTT Broker서버의 보안성을 강화하는 것에 대한 주제로 포스팅을 하게 되었습니다.
이미 보안에 대한 문제점이 있는 것은 오래전부터 인지하고 있었으나, 그 동안 여러가지 긴급한 문제들을 대응하다보니 빠르게 조치를 취하지 못했습니다.</p>

<p>다행히 올해 5월부터 수행하고 있는 클린팩토리 정부R&amp;D과제를 통해서 기존 에어릭스의 스마트팩토리 솔루션들이 가지고 있던 문제점들을 대대적으로 개선할 수
있는 기회를 가지게 되었습니다.</p>

<p>그 중에서도 가장 우선적으로 개선된 부분이 MQTT Broker서버의 보안성 강화인데, 이번 포스팅을 통해서 그 과정을 정리해보기로 했습니다.</p>

<h2 id="문제점">문제점</h2>

<hr />

<p>저희 에어릭스에서는 주로 MQTT 프로토콜을 사용하여 제조현장에 설치된 센서나 PLC로부터 데이터를 수집하고 있습니다. 데이터를 수집하기 위해서 
사내에 MQTT Broker가 설치된 서버도 운영하고 있습니다.</p>

<p>MQTT Broker 서버가 에어릭스의 스마트팩토리 시스템에서 중추적인 역할을 하고 있다는 것은 부인할 수 없는 사실일 것입니다. 하지만 문제는 이렇게 
중요한 MQTT Broker 서버를 그 어떤 보안 매커니즘도 없이 개방된 인터넷 공간에 활짝 공개해놓고 사용하고 있다는 점입니다.</p>

<p>보호되지 않는 MQTT Broker서버에 대한 외부 공격이 데이터 유출을 유발하고, 시스템의 통제권을 빼앗아 이와 연동된 설비나 다른 시스템을 위험에 빠트릴 수도 있습니다.<br />
뉴스 기사에서도 이미 여러차례 이런 문제점들이 지적된 것을 찾아볼 수 있었습니다. 그런 점에서 보면 에어릭스 뿐만 아니라 IoT기술을 사용하고 있는 대다수 업체들이 가지고 
있는 만연한 문제일지도 모르겠습니다.</p>

<p>에어릭스에 입사하기 전에 17년 이상을 임베디드 보안 소프트웨어를 개발하던 업무를 해왔던 제 입장에서는 크나큰 위험요소로 
느껴지는 것이 당연할지도 모르겠습니다.</p>

<p>사실 MQTT Broker 자체의 보안에는 큰 문제가 있습니다. 보안이라는 것 자체를 생각하지 않고, 오직 동작에만 충실한 나머지 제대로된 설정을 하지 않고
사용하고 있는 대다수 업체들의 잘못인 것입니다.</p>

<h2 id="제약사항">제약사항</h2>

<hr />

<ul>
  <li>개방된 인터넷망에서 MQTT Broker 서버를 계속 운영해야 함.</li>
  <li>회사 경영진으로부터 고가의 보안장비를 구입할 예산을 승인받는 것은 거의 불가능함.</li>
  <li>사내 개발자들의 보안기술에 대한 이해도가 부족함.</li>
</ul>

<h2 id="해결과정">해결과정</h2>

<hr />

<p>위와 같은 제약사항이 존재하는 상태에서 MQTT Broker서버의 보안성을 강화하기 위해서 아래와 같은 조치를 취했습니다.</p>

<h3 id="1익명접속-금지-및-aclaccess-control-list-관리">1.익명접속 금지 및 ACL(Access Control List) 관리</h3>

<p>사용자 계정과 비밀번호의 확인없이 접속을 허용하는 익명접속을 더 이상 허용하지 않도록 MQTT Broker서버의 설정을 변경하였습니다.
익명접속을 허용한 상태에서 개방된 인터넷망에서 MQTT Broker서버를 사용하는 것은 집에서 인터넷 공유기의 Password를 설정하지 않은 상태에서
사용하는 것과 마찮가지로 다양한 보안 위협에 그대로 노출될 수 있습니다.
충분하지는 않겠지만 익명접속을 허용하지 않고, 사용자 계정과 비밀번호를 확인하도록 하는 것만으로도 1차적인 방어선을 갖출 수 있습니다.</p>

<p>또한, MQTT Broker서버가 제공하는 ACL 관리 기능을 사용하도록 설정을 변경하기도 했습니다.
ACL 관리 기능을 통해서 사용자 계정별로 허용된 TOPIC을 가진 메시지에만 접근(메시지 구독 or 발행)할 수 있도록 권한을 부여했습니다.</p>

<p>기존에는 누구나 제약없이 자유롭게 MQTT Broker서버로 발행되는 메시지를 가져갈 수 있었습니다. 하지만 이렇게 설정을 변경함으로써 이제는 
사용자 계정과 비밀번호를 통해서 서버 접근 권한이 있는지 확인하고, 해당 계정에 허용된 TOPIC을 가진 메시지만 가져가도록 제어할 수 있게 되었습니다.</p>

<h3 id="2sslsecure-sockets-layer-통신-프로토콜-사용">2.SSL(Secure Sockets Layer) 통신 프로토콜 사용</h3>

<p>MQTT Broker서버가 SSL통신 프로토콜을 사용하여 전송 데이터를 암호화할 수 있도록 했습니다. SSL을 사용하지 않는 경우에는 평문 그대로 데이터가
전송되기 때문에 민감한 정보들이 그대로 외부에 노출될 수 있다는 문제가 있습니다.</p>

<p>SSL은 전송 데이터의 암호화를 위해서 비대칭키 암호화 알고리즘을 사용합니다. 서버의 키를 공개키를 클라이언트로 전달하기 위해서 신뢰할 수 있는
CA로부터 발급받은 서버 인증서가 사용됩니다. 서버 인증서를 검증하고 서버의 공개키를 추출하기 위해서는 CA인증서의 발급도 필요합니다.</p>

<p>하지만 제약사항에 있는 것처럼 별도의 예산을 승인받기는 어려운 상황이었기 때문에 우선은 비용이 발생하지 않는 OpenSSL을 사용해서 필요한 인증서
파일들을 생성해서 사용했습니다.</p>

<p>MQTT Broker서버가 SSL을 사용하여 통신을 할 수 있도록 필요한 인증서 파일들을 등록해주고, 설정을 변경했습니다.</p>

<p>이렇게 SSL을 사용하도록 MQTT Broker서버의 설정을 변경함으로써 데이터의 기밀성(Confidentiality)과 무결성(Integrity)을 보장받을 수 있게 되었습니다.</p>

<h3 id="3vpnvirtual-private-network-사용">3.VPN(Virtual Private Network) 사용</h3>

<p>익명접속 금지 및 ACL관리, 그리고 SSL 통신 프로토콜 사용만으로도 기존 대비 MQTT Broker서버의 보안은 한층 강화되었습니다. 하지만 이것만으로는
충분하지 않다고 생각되었습니다.</p>

<p>원천적으로 MQTT Broker서버가 사용하는 네트워크에 외부의 접속을 차단하고 싶었습니다. 그래서 VPN 사용을 생각했습니다.
VPN을 사용하게 되면 MQTT Broker서버와 통신하는 모든 장치들 사이에는 암호화된 보안 터널이 생성되고, 이를 통해서 안전하게 데이터가 전송되게 됩니다.
개방된 인터넷망을 사용하더라도 암호화된 보안 터널을 통해서 연결되기 때문에 MQTT Broker서버와 장치가 개인 네트워크에 직접 연결된 것과 같은 효과를 가질 수 있습니다.</p>

<p>물론 시중에 나와있는 상용 VPN솔루션을 사용하면 더 좋은 성능과 높은 보안성을 보장받을 수도 있을 것입니다. 하지만 그럴 수 없는 상황이었기 때문에 
비용이 발생하지 않는 OpenSource VPN 솔루션인 WireGuard를 채택해서 사용했습니다.</p>

<h2 id="남은-이슈">남은 이슈</h2>

<hr />

<p>보안성 강화를 위해서 여러가지 조치들을 취했는데 과연 객관적으로 어느 정도 보안성의 강화가 이루어졌는지 측정해 볼 필요가 있을 것 같습니다. 
나중에 기회가 된다면 모의해킹 업체에 의뢰해서 확인해볼 예정입니다.</p>]]></content><author><name>이상훈</name></author><summary type="html"><![CDATA[안녕하세요? 에어릭스 환경시스템 사업부 개발팀장 이상훈입니다. 이번에는 MQTT Broker서버의 보안성을 강화하는 것에 대한 주제로 포스팅을 하게 되었습니다. 이미 보안에 대한 문제점이 있는 것은 오래전부터 인지하고 있었으나, 그 동안 여러가지 긴급한 문제들을 대응하다보니 빠르게 조치를 취하지 못했습니다.]]></summary></entry><entry><title type="html">(3) PLC [통신 프로토콜, 인터페이스]</title><link href="http://localhost:4000/2022/09/12/plc_protocol.html" rel="alternate" type="text/html" title="(3) PLC [통신 프로토콜, 인터페이스]" /><published>2022-09-12T00:00:00+09:00</published><updated>2022-09-12T00:00:00+09:00</updated><id>http://localhost:4000/2022/09/12/plc_protocol</id><content type="html" xml:base="http://localhost:4000/2022/09/12/plc_protocol.html"><![CDATA[<h1 id="3-plc-통신-프로토콜-인터페이스">(3) PLC [통신 프로토콜, 인터페이스]</h1>

<p>이전 장에서는 PLC 프로그램을 작성하기 위해 사용되는 툴과 PLC 메모리 영역과 주소에 대해서 설명하며 알아보았습니다. 이번에는 PLC의 통신 프로토콜 구조와 통신 프로토콜을 통한 인터페이스 방식에 대해서 알아보도록 하겠습니다.</p>

<h3 id="plc-통신-프로토콜">PLC 통신 프로토콜</h3>

<hr />

<p>PLC와 통신을 하기 위해 사용되는 프로토콜이며, 제조사 별로 구성이 되어있습니다. LS 산전 ‘<code class="language-plaintext highlighter-rouge">FEnet(FastEthernet)</code>’, 미쯔비시 ‘<code class="language-plaintext highlighter-rouge">MC(MelsecCommunication)</code> 프로토콜’ 등이 있으며, 범용적으로 사용되고 있는 ‘<code class="language-plaintext highlighter-rouge">Modbus</code>’ 프로토콜이 있습니다. 이번 장에서는 FEnet 프로토콜을 대표적으로 설명을 하도록 하겠습니다.</p>

<p>FEnet은 XGT 전용 프로토콜이며, PLC와 통신하여 PLC 메모리에 데이터를 읽거나 쓰기 위해서 사용합니다. FEnet은 TCP와 UDP 2가지 방식으로 사용이 가능하며 TCP 경우에는 2004번 포트를 사용하고, UDP 경우에는 2005번 포트를 사용하도록 되어 있습니다.</p>

<p>FEnet 프로토콜이  구성은 다음과 같습니다. 이더넷 프레임이 구조를 먼저 살펴보면, 이더넷 통신을 위한 MAC, IP 헤더, TCP 헤더와 데이터를 포함한 LS IS 프레임으로 구성되어 있습니다. PLC와 인터페이스를 하기 위해서 필요한 정보들은 LS IS 프레임에 들어있다고 보시면 될 것 같습니다.</p>

<p><img src="/img/posts/plc_ethernet_frame.png" alt="Ethernet Frame" /></p>

<p>Ethernet Frame</p>

<p>여기에서 LS IS 프레임의 구조를 살펴보면 LS 산전 고유 데이터를 나타내는 Company Header,  요청 명령어를 나타내는 Command, PLC 데이터 타입을 나타내는 Data Type, 데이터를 나타내는 Data가 포함되어 있습니다. 자세한 구조와 나타내는 정보들은 아래 그림과 같습니다.</p>

<p><img src="/img/posts/plc_ls_frame.png" alt="LS IS Frame Format" /></p>

<p>LS IS Frame Format</p>

<p>좀 더 자세하게 설명해야 할 부분들은 Company Header 영역에서 프레임 방향과 길이, Data 영역에서 블록 개수, 변수 길이, 데이터 주소에 대해서 설명하겠습니다.</p>

<p>Company Header 영역의 프레임 방향은 ‘Host → PLC , PLC → Host’ 즉, 요청과 응답에 대해서 나타내고 있고, 길이의 경우에는 Company Header를 제외한 나머지 프레임 정보에 대한 길이의 정보를 나타내고 있습니다.</p>

<p>데이터 영역의 블록 개수는 변수 길이부터 데이터 개수까지 요청되는 정보가 몇개가 있는지를 나타내는 정보입니다. 사진에서 확인이 가능하듯이 여러 개의 요청은 16개 정도로 제한을 두고있습니다. 변수 길이는 데이터 주소의 길이를 표현합니다. 예를 들어서 데이터 주소가 ‘%MW0001’일 경우, 7글자를 나타내는 h’07이 들어가게 되는 것입니다. 데이터 주소는 이전 장에서 설명하였던 PLC 메모리 주소에 대한 정보를 나타내고 있습니다.</p>

<p>읽기 명령을 구성할 때 개별 주소 읽기와 주소 연속 읽기로 구분이 되어질 수 있습니다. 개별 주소는 읽고 싶은 메모리 주소들을 특정하여 요청하는 것이고 주소 연속은 처음 메모리 주소에서부터 주소의 길이 만큼 한번에 읽는 것을 의미합니다. 쓰기 명령의 요청 또한 동일합니다.</p>

<aside>
💡 변수 연속은 데이터 타입이 바이트 타입의 주소만 사용이 가능합니다.

</aside>

<p>해당 프로토콜을 통해서 PLC 메모리의 데이터에 읽기와 쓰기의 명령을 통해서 PLC와 인터페이스를 합니다.</p>

<hr />

<p>통신 프로토콜을 통해서 PLC와 <code class="language-plaintext highlighter-rouge">요청</code>과 <code class="language-plaintext highlighter-rouge">응답</code>에 대해 차이점이 있는지에 대해서 살펴보도록 하겠습니다.</p>

<p>PLC 에게 통신 프로토콜 형식에 맞추어서 요청을 보내게 되면 PLC 에서는 명령어 수행에 대한 응답을 보내주게 되어있습니다. 응답 프레임에서는 데이터 영역에 요청 프레임의 형식이 잘못되었는지 혹은 PLC에 이상이 있는지에 대한 ‘오류 코드’와 정상적으로 수행이 되었다면 요청에 대한 ‘데이터’가 담겨져 있습니다.</p>

<p><img src="/img/posts/plc_response_data.png" alt="응답 프레임 Data 영역" /></p>

<p>응답 프레임 Data 영역</p>

<p>그림에서와 같이 Data 영역의 에러 상태에는 오류 코드가 담겨있으며, 정상일 경우에는 ‘0’으로 보내지며, 그 외의 경우에는 각 상태를 나타내는 정보가 담겨져 있습니다.</p>

<p>데이터에는 읽기 명령어와 쓰기 명령어에 따라 형태가 달라지게 됩니다. 읽기의 경우에는 ‘요청한 블록 수, 데이터 크기, 데이터 정보’가 반복되어 표시되는 반면에 쓰기의 경우에는 요청한 ‘블록 수’의 정보만 있습니다.</p>

<p>이렇게 에러 상태를 확인하여 정상인 경우에는 데이터가 표시되는 정보를 확인하여 원하는 정보를 얻을 수가 있습니다.</p>

<hr />

<p>여기까지 설명한 내용이 PLC 통신 프로토콜과 인터페이스의 과정에 대해서 설명을 하였습니다. 기본적으로 모든 PLC 통신 프로토콜의 필요한 구성과 인터페이스의 과정은 동일하다고 생각합니다. 설명 글을 쓰면서 이해하기 쉽도록 최대한 정리를 해서 설명을 하다보니 빠진 부분도 많을 수 있다고 생각을 합니다. 부족한 부분들에 대해서는 앞으로 채워나갈 수 있도록 노력해보겠습니다. 여기까지 읽어주셔서 감사합니다.</p>]]></content><author><name>김영규</name></author><summary type="html"><![CDATA[(3) PLC [통신 프로토콜, 인터페이스]]]></summary></entry><entry><title type="html">(2) PLC [프로그램 툴, 메모리, 주소체계]</title><link href="http://localhost:4000/2022/09/07/plc_memory.html" rel="alternate" type="text/html" title="(2) PLC [프로그램 툴, 메모리, 주소체계]" /><published>2022-09-07T00:00:00+09:00</published><updated>2022-09-07T00:00:00+09:00</updated><id>http://localhost:4000/2022/09/07/plc_memory</id><content type="html" xml:base="http://localhost:4000/2022/09/07/plc_memory.html"><![CDATA[<h1 id="2-plc-프로그램-툴-메모리-주소체계">(2) PLC [프로그램 툴, 메모리, 주소체계]</h1>

<p>이전 장에서는 PLC 개요와 동작 방식과 구성에 대해서 설명하며 프로그램에 대해서 알아보았습니다. 이번에는 PLC 프로그램을 작성하기 위해 사용되는 툴과 PLC 메모리 영역과 주소에 대해서 알아보도록 하겠습니다.</p>

<h3 id="프로그램-툴">프로그램 툴</h3>

<hr />

<p>PLC 프로그램을 작성하고 디버깅을 하기 위해서는 각 제조사마다 제공하는 프로그램 툴이 존재합니다. LS 산전의 경우에는 ‘XG5000’, 미쯔비시는 ‘GX Works’, 싸이먼은 ‘CICON’ 등… 존재합니다. 각 프로그램 툴은 제조사에서 제공하여 다운을 받아 사용할 수 있습니다. 소개 글에서는 LS 산전을 기준으로 설명하였습니다.</p>

<p><img src="/img/posts/plc_program_main.png" alt="[ XG5000 ]" /></p>

<p>[ XG5000 ]</p>

<p>PC와 PLC를 USB 혹은 Ethernet으로 연결하여 프로그램 툴을 통해서 PLC 내부의 프로그램을 모니터링 하거나 불러올 수 있으며, 작성한 프로그램을 PLC에 쓸 수 있습니다.</p>

<aside>
💡 처음 연결 시 네트워크 설정이 되어 있지 않기 때문에 USB 연결

</aside>

<ul>
  <li>PLC 네트워크 설정</li>
</ul>

<p>PLC와 통신을 하기위해서는 IP 혹은 Port 번호에 대해서 설정이 필요할 것 입니다. 그럴 때에는 아래이 그림과 같이 PLC 통신 설정을 할 수 있습니다.</p>

<p><img src="/img/posts/plc_network_set.png" alt="PLC Network Setting" /></p>

<p>LS PLC 경우에는 드라이버 (통신 프로토콜)에 따라서 허용 가능한 Port 번호가 달라집니다.</p>

<ul>
  <li>
    <p>XGT 서버 (FEnet)</p>

    <p>TCP : 2004</p>

    <p>UDP : 2005</p>
  </li>
  <li>
    <p>모드버스</p>

    <p>TCP : 502</p>
  </li>
</ul>

<p>① 네트워크 설정 → PLC 의 네트워크 정보 설정을 하여 ‘IP, 서브넷마스크, 게이트웨이’의 주소를 설정합니다.</p>

<p>② 전용 접속 개수 → PLC와 인터페이스를 하기 위해서 접속 허용자 수를 설정합니다.</p>

<p>③ 드라이버 설정 → 통해서 PLC 와 인터페이스를 하기 위한 통신 프로토콜을 결정합니다.</p>

<ul>
  <li>PLC 프로그램 전송</li>
</ul>

<p>PLC 네트워크 설정을 하였다면, 프로그램 툴을 통해서 PLC의 프로그램을 가져와 확인(<code class="language-plaintext highlighter-rouge">읽기</code>)을 하거나 PLC 프로그램 메모리에 올려서 PLC가 프로그램 동작(<code class="language-plaintext highlighter-rouge">쓰기</code>)할 수 있도록 합니다.</p>

<p><img src="/img/posts/plc_program.png" alt="PLC Program Read Write" /></p>

<ul>
  <li>모니터링</li>
</ul>

<p>현재 작성된 프로그램에 대해서 디버깅 혹은 동작을 볼 때 사용하게 됩니다. 이 기능을 통해서 프로그램이 내부에서 어떻게 동작을 하고 있는지 확인할 수가 있습니다.</p>

<p><img src="/img/posts/plc_monitor.png" alt="PLC Monitoring" /></p>

<p>① 모니터 → 작성된 프로그램을 디버깅 혹은 동작 과정을 확인하기 위해서 사용이 됩니다.</p>

<p>② 시스템 모니터 → PLC 의 메모리 데이터 및 시스템 데이터를 확인하기 위해서 사용이 됩니다.</p>

<p>프로그램 다운 링크 : <a href="https://www.ls-electric.com/ko/download/?dc_id=6">https://www.ls-electric.com/ko/download/?dc_id=6</a></p>

<h3 id="메모리">메모리</h3>

<hr />

<p>PLC CPU 모듈에는 데이터를 저장하는 메모리가 존재합니다. 메모리는 사용자가 시스템을 구축하기 위해 작성한 사용자 프로그램을 저장하는 <strong>프로그램 메모리</strong>와 운전 중 데이터를 저장하는 디바이스 영역을 제공하는 <strong>데이터 메모리</strong>가 있습니다. 각 모델마다 메모리의 크기와 영역은 다를 수 있습니다. 기본적으로 각 제조사의 사이트에서 해당 제품에 대한 사양을 확인하여 어떤 영역의 메모리가 존재하는지 확인을 하실 수 있습니다. 아래의 그림은 XGI 시리즈의 데이터 메모리 사양 부분을 나타내는 그림입니다.</p>

<p><img src="/img/posts/plc_memory.png" alt="PLC Memory Spec" /></p>

<p>데이터 메모리 영역마다 특징이 존재하고 있습니다. 몇 가지만 알아보도록 하겠습니다.</p>

<table>
  <thead>
    <tr>
      <th>구분</th>
      <th>특징</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>직접 변수</td>
      <td>프로그램에 사용되는 변수 값을 저장하기 위해서 사용할 때</td>
    </tr>
    <tr>
      <td>시스템 플래그</td>
      <td>CPU에 이미 선언되어 PLC 상태를 나타내거나 동작 설정에 대해서 나타낼 때</td>
    </tr>
    <tr>
      <td>아날로그 데이터</td>
      <td>아날로그 , 고속카운트, 온도, 위치결정 등 아날로그의 데이터를 사용할 때</td>
    </tr>
    <tr>
      <td> </td>
      <td> </td>
    </tr>
    <tr>
      <td>고속 링크 플래그</td>
      <td>고속 링크 통신 기능을 수행할 때 통신의 응답 진단을 위해서 사용할 때</td>
    </tr>
    <tr>
      <td>서비스 상태와 에러 내용을 확인 가능</td>
      <td> </td>
    </tr>
    <tr>
      <td>P2P 파라미터</td>
      <td>P2P에서 파라미터 측정한 내용</td>
    </tr>
  </tbody>
</table>

<p>메모리 영역에 ‘리테인 설정’을 하게되면 PLC가 정지(종료) 후 재 가동을 하여도 메모리의 데이터가 지워지지 않고 계속해서 유지하고 있습니다. 이전 데이터가 계속 유지가 되어야 한다면 리테인 설정이 가능한 메모리 영역에서 작업을 하는 것이 좋습니다.</p>

<h3 id="주소-체계-표현">주소 체계 표현</h3>

<hr />

<p>모든 PLC는 비트(Bit)로 데이터를 표현하고 계산을 하는데, 이 비트들이 모여서 단위를 다음과 같이 나타내게 됩니다.</p>

<ul>
  <li>비트 (Bit) ⇒ 1 Bit</li>
  <li>바이드(Byte) ⇒ 1 Byte = 8 Bit</li>
  <li>워드(Word) ⇒ 1 Word = 2 Byte = 16 Bit</li>
  <li>더블워드(Double Word) ⇒ 1 Double Word = 2 Word = 4 Byte = 32 Bit</li>
  <li>롱워드(Long Word) ⇒ 1 Long Word = 2 Double Word = 4 Word = 8 Byte = 64 Bit</li>
</ul>

<p>단위가 나타내는 내용은 다음과 같이 주소에서 표현을 할 수 있습니다.</p>

<table>
  <thead>
    <tr>
      <th>단위</th>
      <th>표현</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>Bit</td>
      <td>X</td>
    </tr>
    <tr>
      <td>Byte</td>
      <td>B</td>
    </tr>
    <tr>
      <td>Word</td>
      <td>W</td>
    </tr>
    <tr>
      <td>Double Word</td>
      <td>D</td>
    </tr>
    <tr>
      <td>Long Word</td>
      <td>L</td>
    </tr>
  </tbody>
</table>

<p>위에 설명한 내용을 종합적으로 합쳐서 PLC의 메모리 주소에 접근할 때 나타내는 주소의 표현을 예를 들어서 설명하겠습니다.</p>

<p>예를 들어 메모리 영역 중 ‘M’의 주소 ‘1번지’의 단위는 ‘워드’를 나타낼 때 ‘%MW0001’로 표현을 하게 됩니다. 실제 PLC 프로그램에서는 ‘%’ 문구를 생략하여 사용할 수 있지만 PLC와 통신 프로토콜을 이용하여 사용할 때에는 붙여서 사용하게 됩니다.</p>

<aside>
💡 LS 산전 PLC 에서는 주소를 나타낼 때 앞에 ‘%’ 문구 포함됨

</aside>

<hr />

<p>여기까지 설명한 내용이 PLC를 설정하거나 프로그램을 작성할 때 사용되는 툴에 대한 설명과 PLC의 메모리가 어떤 종류가 있으며 해당 메모리를 어떻게 사용이 되는지, 메모리의 데이터에 접근하기 위해서 지정되는 주소 체계 방식에 대해서 설명하였습니다. 다음 내용에는 PLC의 통신 프로토콜 구조와 통신 프로토콜을 통한 인터페이스 방식에 대해서 설명을 하도록 하겠습니다.</p>]]></content><author><name>김영규</name></author><summary type="html"><![CDATA[(2) PLC [프로그램 툴, 메모리, 주소체계]]]></summary></entry><entry><title type="html">(1) PLC [PLC 개요, 동작, 분류, 프로그램]</title><link href="http://localhost:4000/2022/09/05/plc_overview.html" rel="alternate" type="text/html" title="(1) PLC [PLC 개요, 동작, 분류, 프로그램]" /><published>2022-09-05T00:00:00+09:00</published><updated>2022-09-05T00:00:00+09:00</updated><id>http://localhost:4000/2022/09/05/plc_overview</id><content type="html" xml:base="http://localhost:4000/2022/09/05/plc_overview.html"><![CDATA[<h1 id="1-plc-plc-개요-동작-분류-프로그램">(1) PLC [PLC 개요, 동작, 분류, 프로그램]</h1>

<p>PLC 통신 프로토콜을 통해서 PC와 인터페이스를 할 수 있도록 개발을 하면서 필요한 PLC에 대한 내용들을 작성해봅니다. 우선적으로, PLC가 어떤 것인지 그리고 어떻게 구성이 되어있고 동작 방식에 대해서 작성하였습니다.</p>

<h3 id="plc">PLC</h3>

<p><strong>Programmable Login Control</strong> 의 약자로 <code class="language-plaintext highlighter-rouge">프로그램</code> 가능한 <code class="language-plaintext highlighter-rouge">논리 제어 장치</code>를 나타내며, 과거 릴레이 회로 제어의 불편함을 개선하기 위해서 개발이 되었습니다. 배선을 프로그램이 대신해서 기계를 동작 시킵니다.</p>

<p><img src="/img/posts/plc_image.png" alt="Image Alt PLC" /></p>

<h3 id="동작">동작</h3>

<p>동작 방식은 입력 장치(센서 정보)로 받아들인 뒤에 메모리에 작성되어 있는 프로그램에 의해서 순차적으로 논리를 처리하고 결과를 출력하여 외부 장치를 제어하는 방식으로 <code class="language-plaintext highlighter-rouge">직렬 처리 방식</code>입니다.</p>

<h3 id="분류">분류</h3>

<p>PLC를 분류하자면 <strong>일체형</strong>과 <strong>모듈형</strong>으로 나눌 수 있습니다.</p>

<ul>
  <li>일체형</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">하나의 장치</code>에 전원장치 , CPU , 메모리 , 입출력 기능이 모두 들어있습니다.  보통 일체형 PLC는 <strong>소형</strong>으로 제작되어 모듈형 PLC 보다 <code class="language-plaintext highlighter-rouge">저사양</code>으로 간단한 설비의 자동화나 단독 제어 설비에 사용이 되어집니다.</p>

<ul>
  <li>모듈형</li>
</ul>

<p><code class="language-plaintext highlighter-rouge">기능에 따라서 모듈</code>로 나뉘어져 있으며 <strong>전원, 연산, 입력, 출력</strong>으로 4가지로 구성되어 있다고 볼 수 있다. 전원은 PLC에 파워를 공급해주는 파워모듈, 연산은 논리/산술 연산 처리 와 메모리 가능을 담당하는 CPU 모듈, 입력은 외부의 신호를 받을 수 있는 모듈, 출력은 연산을 처리한 뒤 결과를 외부 신호로 보내는 모듈을 나타냅니다.</p>

<p>PLC 모듈을 찾다보면 <code class="language-plaintext highlighter-rouge">특수 모듈</code>이라는 것이 있는데 특수 모듈은 <code class="language-plaintext highlighter-rouge">고도화되거나 특수한 작업</code>이 필요한 경우에 대해서 사용되어 지는 모듈입니다. 예를 들어서 온도 제어 혹은 위치 결정 제어 등이 있습니다.</p>

<h3 id="프로그램">프로그램</h3>

<p>PLC 프로그램을 하기 위해 당연하게도 언어가 사용이 됩니다. 그 언어의 종류는 LD (래더), ST(구조 언어), FB(기능 블록) 등 존재합니다. 제가 가장 많이 본 것은 래더 언어이며 PLC 프로그램 예시를 찾다보면 흔하게 만날 수 있습니다. 래더는 아래의 이미지와 같이 생겼습니다.</p>

<p><img src="/img/posts/plc_ld.png" alt="Image Alt LD" /></p>

<p>여기서 가장 중요한 것은 <code class="language-plaintext highlighter-rouge">마지막에 END가 들어가야 한다는 것</code>입니다. 마지막에 END가 나타내는 것이 프로그램이 끝났다는 것을 알려주는 것 입니다.</p>

<p>다음으로, 개발자의 입장에서 가장 친근하게 접근할 수 있는 ST(구조 언어)입니다. 이미지와 같이 C 언어나 Java 등 개발 언어에 사용하는 방식과 같이 사용이 된다는 것을 확인할 수 있습니다.</p>

<p><img src="/img/posts/plc_st.png" alt="Image Alt ST" /></p>

<p>그 외에도 언어의 종류가 더 있지만 여기에선 생략하고 넘어가도록 하겠습니다..</p>

<p>프로그램을 작성하였다면 어떤 방식으로 진행이 되는 지가 궁금할 것이라고 생각이 됩니다. PLC 프로그램은 순차적으로 실행이 됩니다. 
여기에서 LD 언어로 작성된 프로그램이 동작한다고 가정하였을 때, 프로그램은 위에서 순차적으로 내려올 것 입니다. 이때, 마지막에 만나는 END 지점에 도착했다고 끝나는 것이 아니라 다시 처음부터 시작이 됩니다. 이렇게 프로그램이 계속해서 실행이 되고 있다고 보면 될 것입니다. 
이 부분에서 상세히 설명하면 일정한 스캔 주기마다 프로그램이 순차적으로 실행이 되고 있기 때문에 입력 신호가 변경이 되더라도 프로그램을 다시 스캔되지 않는 이상 처리되지 않고 있다가 다시 스캔이 시작되고 나서야 처리가 된다고 볼 수 있습니다. 
여기에서 프로그램 1바퀴를 다 도는 것을 ‘<code class="language-plaintext highlighter-rouge">1 스캔</code>‘이라고 부르며 하나의 접점에 대해서는 ‘<code class="language-plaintext highlighter-rouge">1 스탭</code>‘이라고 합니다. 개발자의 입장에서 이벤트 처리 방식과는 다르다고 볼 수 있습니다. PLC 프로그램이 대기 형태를 가지고 있는 것이 아닌 지속적인 스캔이 되어서 해당 신호에 맞게 처리가 되고 있다고 이해하면 될 것 같습니다.</p>

<hr />

<p>여기까지 설명한 내용이 PLC가 어떤 것이고 동작 방식과 프로그램이 어떻게 동작하는 것인지에 대해서 간략하게 설명을 했습니다. 다음 내용에는 PLC 프로그램 사용에 쓰이는 도구와 PLC 메모리 구조 내용들에 대해서 설명을 하도록 하겠습니다.</p>]]></content><author><name>김영규</name></author><summary type="html"><![CDATA[(1) PLC [PLC 개요, 동작, 분류, 프로그램]]]></summary></entry><entry><title type="html">클린팩토리</title><link href="http://localhost:4000/2022/08/31/cleanfactory.html" rel="alternate" type="text/html" title="클린팩토리" /><published>2022-08-31T00:00:00+09:00</published><updated>2022-08-31T00:00:00+09:00</updated><id>http://localhost:4000/2022/08/31/cleanfactory</id><content type="html" xml:base="http://localhost:4000/2022/08/31/cleanfactory.html"><![CDATA[<p>환경시스템사업부에서 올해(2022년)부터 수행하고 있는 정부R&amp;D과제 중 하나인 <code class="language-plaintext highlighter-rouge">클린팩토리</code> 사업을 소개합니다.</p>

<p>과제의 정식명칭은 <code class="language-plaintext highlighter-rouge">제조 사업장 내 클린팩토리 진단∙관리 서비스 제공을 위한 고성능 센서 및 AI기반의 클라우드 서비스형 산업용 IoT플랫폼 개발</code>이며, 과제명이
길다보니 줄여서 그냥 <strong>클린팩토리</strong>과제로 부르고 있습니다.</p>

<p>중기부와 과기부에서 총괄하고 있는 <code class="language-plaintext highlighter-rouge">스마트제조혁신기술개발사업</code>에 포함되어 있는 여러 세부과제 중 하나이며, DNA(Data,Network,AI) 기술 기반의 
스마트 제조혁신 가속화와 스마트공장 공급기업의 경쟁력을 제고하기 위해서 추진되고 있는 사업입니다.</p>

<hr />

<h2 id="연구개발과제-개요">연구개발과제 개요</h2>

<p>본 연구개발과제의 개요는 다음과 같습니다.</p>

<ul>
  <li>과제명 : <code class="language-plaintext highlighter-rouge">제조 사업장 내 클린팩토리 진단∙관리 서비스 제공을 위한 고성능 센서 및 AI기반의 클라우드 서비스형 산업용 IoT플랫폼 개발</code></li>
  <li>과제목표 :
    <ul>
      <li>중소/중견 제조 사업장에 적용 가능한 클린팩토리 진단∙관리 기술 개발</li>
      <li>클린팩토리 진단∙관리 기술을 IT서비스로 구현하고 운영할 수 있는 플랫폼을 구축</li>
      <li>다양한 환경에서의 실증연구를 통한 클린팩토리 진단∙관리 기술 검증</li>
    </ul>
  </li>
  <li>발주처 : 중기부 스마트제조혁신추진단</li>
  <li>사업기간 : 2022.05 ~ 2025.12 (44개월)</li>
  <li>총 예산 : 42억원(정부출연금 32억)</li>
  <li>컨소시움 구성 :
    <ul>
      <li>주관연구기관 - <code class="language-plaintext highlighter-rouge">에어릭스</code></li>
      <li>공동연구기관 - 포항산업과학연구원(RIST), 서울과학기술대학교 산학협력단, 피앤피, 오성시스템</li>
      <li>위탁연구기관 - <code class="language-plaintext highlighter-rouge">포스코</code></li>
    </ul>
  </li>
</ul>

<p><img src="/img/posts/cleanfactory_01.png" alt="Image Alt 과제개요" /></p>

<hr />

<h2 id="연구개발의-필요성">연구개발의 필요성</h2>

<p>본 과제의 연구개발 필요성은 제조 사업장의 클린팩토리 조성에 대한 수요 증가와 IT 기술을 활용한 클린팩토리 진단·관리 시스템 구축 사례 증가로 설명할 수 있습니다.</p>

<h4 id="제조-사업장의-클린팩토리-조성에-대한-수요-증가">제조 사업장의 클린팩토리 조성에 대한 수요 증가</h4>

<ul>
  <li>클린팩토리란 제조 사업장에서 발생하는 미세먼지, 온실가스, 화학물질, 폐기물 등의 오염물질의 발생을 최소화한 사업장을 의미함.</li>
  <li>대한민국 2050 탄소중립 전략과 그린뉴딜 정책으로 인한 정부의 요구와, 제조 사업장 발생 오염물질 관리에 대한 사회적 이슈의 심화로 각종 중소·중견 제조 사업장의 환경 개선에 대한 부담이 증가함.</li>
  <li>다수의 국내 제조사업장에서는 환경 모니터링 시스템 마련 및 운영 비용의 부담, 관련 전문가의 부재, 공정 연계 기술 부족의 이유로 환경 관리에 어려움을 겪고 있음.</li>
</ul>

<p><img src="/img/posts/cleanfactory_02.png" alt="Image Alt 4대 환경 관리요소" /></p>

<h4 id="it-기술을-활용한-클린팩토리-진단관리-시스템-구축-사례-증가">IT 기술을 활용한 클린팩토리 진단·관리 시스템 구축 사례 증가</h4>

<ul>
  <li>대부분의 시스템이 제조 사업장 모니터링 기능 구현에 집중되어 있음.</li>
  <li>IoT 기술에 환경 기술과 AI 데이터 분석 기술을 접목한 클린팩토리 진단∙관리 시스템의 필요성이 제기되고 있음.</li>
  <li>시스템 구축 및 운영 비용의 부담, 시스템 운영에 필요한 전문인력 부재, 요구사항 불충족, 기존 시스템과의 통합 문제 등 많은 중소·중견 제조 사업장에서 시스템 도입에 대해서 여전히 어려움을 겪고 있음.</li>
</ul>

<p><img src="/img/posts/cleanfactory_03.png" alt="Image Alt 제조현장" /></p>

<hr />

<h2 id="목표시스템">목표시스템</h2>

<p><img src="/img/posts/cleanfactory_04.png" alt="Image Alt 에어릭스" /></p>

<h2 id="관련-링크">관련 링크</h2>

<p><a href="https://eiec.kdi.re.kr/policy/materialView.do?num=226520&amp;topic=O&amp;pp=20&amp;datecount=&amp;recommend=&amp;pg=">KDI 경제정보센터 - 중기부/과기정통부, 스마트 제조혁신 기술개발(R&amp;D) 2,418억원 지원</a></p>

<p><img src="/img/posts/iomt_rnd_04.png" alt="Image Alt 에어릭스" /></p>]]></content><author><name>이상훈</name></author><summary type="html"><![CDATA[환경시스템사업부에서 올해(2022년)부터 수행하고 있는 정부R&amp;D과제 중 하나인 클린팩토리 사업을 소개합니다.]]></summary></entry><entry><title type="html">의료 IoMT 플랫폼 구축</title><link href="http://localhost:4000/2022/08/31/iomt_rnd.html" rel="alternate" type="text/html" title="의료 IoMT 플랫폼 구축" /><published>2022-08-31T00:00:00+09:00</published><updated>2022-08-31T00:00:00+09:00</updated><id>http://localhost:4000/2022/08/31/iomt_rnd</id><content type="html" xml:base="http://localhost:4000/2022/08/31/iomt_rnd.html"><![CDATA[<p>환경시스템사업부에서 2020년부터 수행하고 있는 정부R&amp;D과제 중 하나인 <code class="language-plaintext highlighter-rouge">의료 IoMT 플랫폼</code> 구축 사업을 소개합니다.</p>

<p>저희 에어릭스에서 스마트팩토리 시스템 구축시 제조현장의 정보를 수집하기 위해서만 사용해오던 IoT기술을 의료영역이라는
전혀 다른 분야에 적용해보는 도전적인 성격의 과제였습니다. 하지만 다행히 큰 문제없이 3년차 연구까지 진행되고 있습니다. 
현재 저희 에어릭스가 담당한 <code class="language-plaintext highlighter-rouge">환자감시통합모니터링</code> 시스템은 개발이 끝나고, <code class="language-plaintext highlighter-rouge">신촌세브란스 병원 응급진료센터</code>에 설치되어 시범적으로 운영되고 
있는 상황입니다.</p>

<h2 id="연구개발과제-개요">연구개발과제 개요</h2>

<p>본 연구개발과제의 개요는 다음과 같습니다.</p>

<ul>
  <li>과제명 : <code class="language-plaintext highlighter-rouge">환자중심 의료서비스 제공을 위한 인공지능, 클라우드, WiFi6 기반의 병원 대상 IoMT 표준 플랫폼 개발 및 임상 적용</code></li>
  <li>내역사업 : 4차 산업혁명 및 미래 의료 환경 선도</li>
  <li>발주처 : 범부처전주기의료기기연구개발사업단</li>
  <li>사업기간 : 2020.09 ~ 2024.12 (4년4개월)</li>
  <li>총 예산 : 93억원(정부출연금 67.5억)</li>
  <li>컨소시움 구성 :
    <ul>
      <li>주관연구기관 - <code class="language-plaintext highlighter-rouge">헤론헬스정보시스템(구 파이디지털헬스케어)</code></li>
      <li>공동연구기관 - <code class="language-plaintext highlighter-rouge">에어릭스</code>, 연세대학교 산학협력단, LG전자, DKI, 오성시스템, 인포마크, 라이튼테크놀로지, 메인텍, AITRICS</li>
    </ul>
  </li>
</ul>

<h2 id="연구개발의-필요성">연구개발의 필요성</h2>

<p><img src="/img/posts/iomt_rnd_03.png" alt="Image Alt 연구개발의 필요성" /></p>

<h2 id="전체-시스템-구성">전체 시스템 구성</h2>

<p>본 연구개발과제는 비대면 사회 변화에 맞추어 환자중심 의료서비스 제공을 위해서 끊김 없는 데이터 획득(Seamless), 실시간 통합 모니터링(Synchronous),
정교한 예측 서비스 구현(Sophisticated), 병원정보시스템과 다양한 IoMT 기기연동이 가능하도록 <code class="language-plaintext highlighter-rouge">의료IoMT 플랫폼</code>을 구축하는 것을 목표로
하고 있습니다.</p>

<p><img src="/img/posts/iomt_rnd_01.png" alt="Image Alt 전체시스템구성" /></p>

<h2 id="환자감시통합모니터링">환자감시통합모니터링</h2>

<p>에어릭스는 의료IoMT 플랫폼의 핵심기능인 환자감시통합모니터링 시스템을 담당하고 있습니다. 환자감시통합모니터링 시스템을 위한 IRS서버를 구축하고,
이를 통해서 다양한 병원 내 시스템과 연계하여 데이터를 수집/중계하고 있습니다. 이러한 데이터들을 시각화하여 웹 화면을 통해서 환자감시통합모니터링
서비스를 제공하고 있습니다.</p>

<p><img src="/img/posts/iomt_rnd_02.png" alt="Image Alt 환자감시통합모니터링" /></p>

<h2 id="관련-기사-링크">관련 기사 링크</h2>

<p><a href="https://www.etnews.com/20201012000147">전자신문 - 파이디지털헬스케어, 연세의료원과 환자 중심 서비스를 위한 의료 IoMT 플랫폼 구축</a></p>

<p><img src="/img/posts/iomt_rnd_04.png" alt="Image Alt 에어릭스" /></p>]]></content><author><name>이상훈</name></author><summary type="html"><![CDATA[환경시스템사업부에서 2020년부터 수행하고 있는 정부R&amp;D과제 중 하나인 의료 IoMT 플랫폼 구축 사업을 소개합니다.]]></summary></entry><entry><title type="html">새로운 시작</title><link href="http://localhost:4000/2022/08/26/starting.html" rel="alternate" type="text/html" title="새로운 시작" /><published>2022-08-26T00:00:00+09:00</published><updated>2022-08-26T00:00:00+09:00</updated><id>http://localhost:4000/2022/08/26/starting</id><content type="html" xml:base="http://localhost:4000/2022/08/26/starting.html"><![CDATA[<p>안녕하세요? 에어릭스 환경시스템사업부의 기술연구소장과 개발팀장을 겸직하고 있는 이상훈입니다.</p>

<p>저는 에어릭스에 입사하기 전 <code class="language-plaintext highlighter-rouge">스마트팩토리</code>와는 전혀 상관없는 신용(현금)카드 혹은 USIM카드로 사용되는 IC카드용 운영체제 및 어플리케이션 개발 업무를 했었습니다. 그러다가 우연히 에어릭스에 입사하게 되었는데, 벌써 2년 가까운 시간이 흘렀습니다. 정말로 시간의 흐름이 빠른 것 같습니다. 
시간이 흘렀어도 여전히 <code class="language-plaintext highlighter-rouge">스마트팩토리</code> 는 여전히 어려운 분야인 것 같습니다.</p>

<p><img src="/img/posts/starting_00.png" alt="Image Alt 어려움" /></p>

<hr />

<h2 id="변화를-시작해야-할-시점">변화를 시작해야 할 시점</h2>

<p>에어릭스는 IT기업이 아닙니다. 그러다보니 IT기술이나 사업에 대해서 전반적으로 사내 구성원들의 이해도가 부족한 편입니다. 말만 하면 모든 것들이 알아서 마법처럼 구현될 수 있는 것이 아닌데, IT기술에 대한 이해도가 높지 않다보니 잘못된 의사결정을 내리는 경우가 많았습니다.</p>

<p>면밀한 검토없이 잘못된 의사결정으로 무리하게 추진되었던 많은 사업들 때문에 저도 입사 후 최근까지도 그러한 문제들을 수습하는데 많은 에너지를 쏟아야만 했습니다. 
답답한 현실의 벽에 부딪혀 개발인력들의 이탈이 이어지는 것을 막을 수도 없었습니다.</p>

<p><img src="/img/posts/starting_01.png" alt="Image Alt 인력이탈" /></p>

<p>다행히 지금은 많은 것들이 정리가 된 상황으로 안정을 찾아가고 있습니다. 이제야 비로소 그 동안 하지 못했던 일들을 하나씩 하나씩 추진해나갈 수 있는
여유가 생긴것 같습니다. 이제는 변화를 시작해야 할 시점입니다.</p>

<hr />

<h2 id="블로그를-개설하는-이유">블로그를 개설하는 이유</h2>

<p>그 첫 시작이 아마도 기술블로그의 개설이 될 것 같습니다. 기술블로그를 개설해서 운영하려는 이유는 <code class="language-plaintext highlighter-rouge">성장</code>과 <code class="language-plaintext highlighter-rouge">정체성</code>이라는 키워드로
설명할 수 있을 것 같습니다.</p>

<h4 id="성장">성장</h4>

<p>우리 개발팀에는 아직 부족한 부분이 많이 있습니다. 우리 스스로 부족한 부분을 채워나가면서 <code class="language-plaintext highlighter-rouge">성장</code>할 수 있는 발판을 마련해야 합니다.</p>

<p><code class="language-plaintext highlighter-rouge">성장</code>을 위해서 <strong>소통</strong>과 <strong>공유</strong>는 필수적 입니다. <strong>소통</strong>과 <strong>공유</strong>를 통해서 <code class="language-plaintext highlighter-rouge">성장</code>에 필요한 지식과 경험을 채워나갈 수
있기 때문입니다. <strong>소통</strong>과 <strong>공유</strong>에 가장 기본적이면서 효율적인 수단이 바로 글쓰기입니다. 기술블로그를 통해서 공개적으로 배포할
수 있도록 어떤 주제에 대한 자신의 생각이나 의견, 지식 등을 간결하고 명료하게 글로 작성해보는 것은 글쓰기 능력을 향상시키는데
많은 도움이 될 것이라고 생각합니다.</p>

<p>적은 인원으로 효율적인 조직을 만들기 위해서는 무엇보다 협업이 중요합니다. 
협업하기 위해서는 본인의 지식이나 경험, 생각 등을 잘 정리하여 상대방에게 전달할 수 있는 능력이 기본적으로 요구됩니다. 
말로는 정보 전달의 한계가 있기에 글로 전달할 수 있어야 합니다. 그렇기 때문에 구성원들 각자가 가지고 있는 글쓰기 능력이 팀 전체의 
역량과 효율성을 좌우할 수 있다고 생각합니다.</p>

<p>팀의 리더로서 기술블로그 운영을 통해서 우리 팀 구성원들 각자가 글쓰기 훈련을 할 수 있는 계기를 만들어주고 싶습니다.
글쓰기 능력을 향상시켜서 타인과 <strong>소통</strong>하고 <strong>공유</strong>하는 힘을 키우고, 그것이 우리들을 <code class="language-plaintext highlighter-rouge">성장</code>의 지름길로 이끌어 줄 수 있기를 기대해봅니다.</p>

<h4 id="정체성">정체성</h4>

<p>우리가 근무하는 에어릭스라는 회사가 IT회사가 아니다보니 일반적인 IT기업의 조직문화와는 차이가 있습니다. 개발팀도 예외가 아닙니다.
일반적인 IT기업의 개발팀과는 차이가 있습니다. 솔직히 개발팀다운 <code class="language-plaintext highlighter-rouge">정체성</code>을 아직 가지고 있지 못하다고 생각합니다.</p>

<p>기술은 빠르게 발전하고 있습니다. 기술의 발전 흐름에 뒤쳐지지 않고 쫓아가기 위해서라도 계속적으로 <strong>공부</strong>하고, <strong>연구</strong>하는 모습을 보여야 합니다. 
그런 과정들 속에서 배우고, 고민하고, 경험한 것들을 개인의 기억속에만 남겨둔다면, 점차 시간이 흐르면서 기억이 지식으로 축적되지 못하고 결국
사라지거나 왜곡되고 말 것입니다.</p>

<p><strong>공부</strong>하고 <strong>연구</strong>하는 과정들 속에서 배우고, 고민하고, 경험한 것들 속에는 분명 타인에게 도움이 될 수 있는 정보들이 많이 포함되어
있을 것입니다. 기억속 여기저기에 흩어져있는 단편적인 정보들을 잘 취합하고, 정리해서 유용한 지식으로 전환해내기 위해서 글로 작성해보려는
노력을 기울일 필요가 있습니다. 그런 노력들이 모여서 에어릭스 환경시스템 사업부 소속 기술연구소&amp;개발팀의 기술 히스토리로 내재화될 것입니다.
기술 히스토리의 내재화가 없다는 것은 결국 그 조직은 내실이 없다는 의미입니다. 지금까지 우리 기술연구소&amp;개발팀의 모습이 그랬던 것 같습니다.</p>

<p>꾸준히 기술 히스토리를 내재화하면서 개인과 조직이 함께 발전할 수 있는 그런 문화가 만들어졌으면 합니다. 제가 생각하는 개발팀다운 <code class="language-plaintext highlighter-rouge">정체성</code>은
바로 그런 문화를 가진 조직입니다.</p>

<p>물론 한순간에 내실있는 조직으로 탈바꿈하는 건 불가능한 일입니다. 당연히 시간이 필요합니다. 하지만 마냥 기다릴 수도 없습니다.
바로 시작해야 합니다. 성장에 대한 욕구가 있다면 바쁘다는 것이 핑계가 되지는 않을 것입니다. 다만, 옛날 시골마당에서 수동 펌프에 물이 안나올 때에
물을 끌어올리기 위해서 펌프 위에 마중물을 부었던 것처럼 우리에게도 마중물 같은 것이 필요할 수는 있다고 생각합니다. 그리고 저는 기술블로그가 
그 역할을 해줄 수 있을 것이라고 생각합니다.</p>

<hr />

<h2 id="깃허브github를-선택한-이유">깃허브(github)를 선택한 이유</h2>

<p>사실 블로그를 운영할 플랫폼은 많이 있습니다. 사용이 편리한 티스토리나 네이버 블로그를 이용하는 것도 검토를 했었습니다. 하지만 요즘 웬만한 
IT스타트업들이 하는 것처럼 깃허브(github)를 이용해서 기술블로그를 많이 운영하고 싶었습니다. 깃허브가 주는 개발자스러운 느낌을 에어릭스
환경시스템사업부 기술블로그에서도 풍기고 싶었습니다.</p>

<p>에어릭스가 비록 IT기업은 아니지만, 그래도 환경시스템 사업부의 개발팀에 소속된 우리들은 모두 IT개발자들입니다. 
우리가 운영하는 기술블로그만큼에서라도 여느 IT스타트업들처럼 개발자스러움을 가득 보여주고 싶습니다.</p>

<p><img src="/img/posts/starting_02.png" alt="Image Alt github" /></p>

<hr />

<h2 id="글을-마치면서">글을 마치면서…</h2>

<p>우리의 기술블로그가 재미있고 가치있는 글들로 풍성하게 가득 채워지기를 바랍니다.</p>]]></content><author><name>이상훈</name></author><summary type="html"><![CDATA[안녕하세요? 에어릭스 환경시스템사업부의 기술연구소장과 개발팀장을 겸직하고 있는 이상훈입니다.]]></summary></entry></feed>