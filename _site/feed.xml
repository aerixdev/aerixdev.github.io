<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.2">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2023-01-11T17:12:10+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">에어릭스 환경시스템사업부 기술블로그</title><subtitle>IT기업이 아닌 에어릭스에서 살아가고 있는 개발자들</subtitle><author><name>(주)에어릭스</name></author><entry><title type="html">2023년 첫 내부세미나</title><link href="http://localhost:4000/2023/01/09/2023_seminar_1.html" rel="alternate" type="text/html" title="2023년 첫 내부세미나" /><published>2023-01-09T00:00:00+09:00</published><updated>2023-01-09T00:00:00+09:00</updated><id>http://localhost:4000/2023/01/09/2023_seminar_1</id><content type="html" xml:base="http://localhost:4000/2023/01/09/2023_seminar_1.html"><![CDATA[<p>지난 포스팅에서 공지했던 것처럼 개발팀 1월과 2월 내부세미나는 한빛미디어에서 운영하는 혼공학습단 활동으로 대체하기로 했습니다.
혼공학습단 활동방법은 매주 정해진 범위를 스스로 공부하고 학습한 내용과 미션수행 내용을 정리해서 블로그에 포스팅하는 것입니다.</p>

<p>매우 간단하죠? 그런데 이제와서 이야기하는 것이지만 사실 1주차부터 탈락자가 나올까봐 걱정했던 것도 사실입니다. 
다행히 1주차에는 탈락자는 없었습니다.</p>

<h2 id="혼공학습단9기-1주차-학습내용-토의">혼공학습단9기 1주차 학습내용 토의</h2>

<hr />

<p>사실 1주차에는 부담없이 가볍게 읽고 넘어갈 수 있는 내용이라 토의를 할 만한게 없었습니다. 다만, 너무 성의없이 포스팅을 한 것처럼
보이는 강x구 사원한테 잔소리를 했을 뿐이고, 미션문제 풀이에 틀린 답을 올려놓고 100점이죠?라고 자신있게 포스팅했던 손x철 대리한테 왜 그랬냐고
물어봤을 뿐입니다.</p>

<table>
    <tr><img src="/img/posts/2023-01-09/room1.jpg" alt="세미나사진1" width="50%" /></tr>
    <tr><img src="/img/posts/2023-01-09/room2.jpg" alt="세미나사진2" width="50%" /></tr>
</table>

<p><br /></p>

<h2 id="학습내용-포스팅-링크-및-혼공족장님의-평가">학습내용 포스팅 링크 및 혼공족장님의 평가</h2>

<hr />

<p>다음은 개발팀원들이 혼공학습단9기 1주차 학습을 마치고, 올렸던 블로그 포스팅 내용을 확인할 수 있는 접속링크와 그에 대한 혼공족장님의 평가댓글(미션확인용)입니다.</p>

<p><strong><a href="https://blog.naver.com/sclrnd1/222969120393">이상훈 - 학습내용 포스팅</a></strong>
<img src="/img/posts/2023-01-09/이상훈.png" alt="이상훈" width="80%" /></p>

<p><strong><a href="https://devrix.tistory.com/7">손민철 - 학습내용 포스팅</a></strong>
<img src="/img/posts/2023-01-09/손민철.png" alt="손민철" width="90%" /></p>

<p><strong><a href="https://blog.naver.com/kyg931103/222978464499">김영규 - 학습내용 포스팅</a></strong>
<img src="/img/posts/2023-01-09/김영규.png" alt="김영규" width="90%" /></p>

<p><strong><a href="https://velog.io/@thdrldud369/series/%ED%98%BC%EA%B3%B5-%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%B6%84%EC%84%9D">송기영 - 학습내용 포스팅</a></strong>
<img src="/img/posts/2023-01-09/송기영.png" alt="송기영" width="90%" /></p>

<p><strong><a href="https://velog.io/@devkangms/%EC%B1%95%ED%84%B01.-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B6%84%EC%84%9D%EC%9D%84-%EC%8B%9C%EC%9E%91%ED%95%98%EB%A9%B0">강민석 - 학습내용 포스팅</a></strong>
<br />
혼공학습단 신청을 못해서 <code class="language-plaintext highlighter-rouge">깍두기</code>로 참여하는 중이라 혼공족장님 평가가 없습니다.</p>

<p><strong><a href="https://blog.naver.com/ekcapaper/222977397258">강민구 - 학습내용 포스팅</a></strong>
<img src="/img/posts/2023-01-09/강민구.png" alt="강민구" width="90%" /></p>]]></content><author><name>이상훈</name></author><summary type="html"><![CDATA[지난 포스팅에서 공지했던 것처럼 개발팀 1월과 2월 내부세미나는 한빛미디어에서 운영하는 혼공학습단 활동으로 대체하기로 했습니다. 혼공학습단 활동방법은 매주 정해진 범위를 스스로 공부하고 학습한 내용과 미션수행 내용을 정리해서 블로그에 포스팅하는 것입니다.]]></summary></entry><entry><title type="html">PM2 및 오프라인(폐쇄망) 설치</title><link href="http://localhost:4000/2023/01/09/offline_pm2_docker.html" rel="alternate" type="text/html" title="PM2 및 오프라인(폐쇄망) 설치" /><published>2023-01-09T00:00:00+09:00</published><updated>2023-01-09T00:00:00+09:00</updated><id>http://localhost:4000/2023/01/09/offline_pm2_docker</id><content type="html" xml:base="http://localhost:4000/2023/01/09/offline_pm2_docker.html"><![CDATA[<h1 id="pm2-오프라인-설치">PM2 오프라인 설치</h1>

<h2 id="0-개요">0. 개요</h2>

<p>pm2를 폐쇄망 환경에서 설치하려고 하면, 각종 선행 패키지들을 모두 수동으로 설치하는 고통스러운 과정을 거쳐야합니다.
하지만 위대한 선배 개발자의 도움을 통해 쉽게 설치하는 방법이 있어 공유해봅니다.</p>

<p>pm2-installer를 통해 설치하게 되며, 인터넷이 가능한 PC에서 설치 파일 제작 후, 오프라인 PC로 옮겨서 설치하게 됩니다.</p>

<p>pm2-installer 링크.</p>

<p>https://github.com/jessety/pm2-installer</p>

<h2 id="1-같은-버전의-nodejs-설치">1. 같은 버전의 NodeJS 설치</h2>

<p>설치 파일 제작 시, 대상 PC와 파일 제작 PC의 node 및 npm 버전이 동일해야 합니다.</p>

<p>노드 구버전은 다음 링크에서 구할 수 있습니다.
<a href="https://nodejs.org/ko/download/releases/">https://nodejs.org/ko/download/releases/</a></p>

<p>폐쇄망 PC에 노드와 npm이 없다면, 패키지 파일을 다운로드 후 다음과 같은 과정을 거쳐 설치 해줍니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># 인터넷이 가능한 PC에서 다운로드</span>
wget <span class="nv">$파</span>일링크

<span class="c"># USB나 SCP 등을 이용해 설치 대상 PC로 파일을 옮겨줍니다.</span>

<span class="c"># lib 폴더로 옮기기</span>
<span class="nb">mv</span> <span class="nv">$파</span>일 /usr/local/lib

<span class="c"># 파일 압축풀기</span>
<span class="nb">tar </span>xvf <span class="nv">$파</span>일

<span class="c"># 명령어를 통한 바로 실행을 위해 심볼릭 링크 등록</span>
<span class="nb">ln</span> <span class="nt">-s</span> /usr/local/lib/<span class="nv">$노</span>드폴더/bin/<span class="k">*</span> /usr/local/bin/
</code></pre></div></div>

<h2 id="2-pm2-설치-파일-제작">2. PM2 설치 파일 제작</h2>

<p>pm2-installer를 다운받고 압축을 풀어줍니다.  압축 푼 폴더로 이동 후 작업합니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">cd </span>pm2-installer-main

npm run bundle

<span class="c"># pm2 버전에 따라 지원하는 node 버전이 다르므로 확인이 필요합니다.</span>
<span class="c"># pm2 버전 변경이 필요한 경우 다음과 같이 package.json 파일 수정 후에 bundle 명령을 내립니다.</span>

<span class="nb">sudo </span>vi package.json

<span class="s2">"dependencies"</span>: <span class="o">{</span>
    <span class="s2">"@jessety/pm2-logrotate"</span>: <span class="s2">"^2.7.1"</span>,
    <span class="s2">"node-windows"</span>: <span class="s2">"1.0.0-beta.6"</span>,
    <span class="s2">"pm2"</span>: <span class="s2">"4.0.0"</span> &lt;&lt; 버전 변경
  <span class="o">}</span>,
  <span class="s2">"devDependencies"</span>: <span class="o">{</span>
    <span class="s2">"@jessety/eslint-config"</span>: <span class="s2">"^1.0.8"</span>,
    <span class="s2">"editorconfig-checker"</span>: <span class="s2">"^4.0.2"</span>,
    <span class="s2">"eslint"</span>: <span class="s2">"5.16.0"</span> &lt;&lt; 버전 변경
  <span class="o">}</span>
</code></pre></div></div>

<h2 id="3-설치-파일-배포">3. 설치 파일 배포</h2>

<p>bundle 작업을 한 후 폴더 전체를 다시 압축하여 대상 pc로 옮겨줍니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">tar</span> <span class="nt">-cvf</span> bundle.tar pm2-installer-main

<span class="c"># 파일 옮기기</span>
<span class="c"># 대상 PC에서 압축풀기</span>

<span class="nb">tar</span> <span class="nt">-xvf</span> bundle.tar

<span class="c"># 폴더로 이동</span>
<span class="nb">cd </span>pm2-installer-main

<span class="c"># 설치하기</span>
npm run setup

<span class="c"># 심볼릭 링크 등록</span>
<span class="nb">ln</span> <span class="nt">-s</span> /usr/local/lib/<span class="nv">$노</span>드폴더/bin/<span class="k">*</span> /usr/local/bin/
</code></pre></div></div>

<p>설치가 완료되었습니다.</p>

<h3 id="외전-docker-오프라인-설치">외전. Docker 오프라인 설치</h3>

<p>폐쇄망에서 Docker를 설치하는 방법은 더욱 간단합니다.
아래 링크에서 원하는 Dockere 패키지를 다운 받습니다.</p>

<p>https://download.docker.com/linux/static/stable/x86_64/</p>

<p>SCP나 USB등의 방법을 활용해 폐쇄망으로 패키지 파일을 옮겨준 후, 압축을 풀어줍니다.</p>

<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">tar</span> <span class="nt">-xvf</span> <span class="nv">$도</span>커압축파일
</code></pre></div></div>

<p>이후 압축 풀어서 나온 모든 파일을 /usr/bin/ 폴더로 옮겨주면 docker 실행이 가능합니다.</p>
<div class="language-bash highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nb">sudo mv</span> <span class="nv">$압</span>축해제한폴더/<span class="k">*</span> /usr/bin

<span class="c">#도커 실행</span>
<span class="nb">sudo </span>dockered &amp;
</code></pre></div></div>]]></content><author><name>강민석</name></author><summary type="html"><![CDATA[PM2 오프라인 설치]]></summary></entry><entry><title type="html">혼공스터디9기 활동시작</title><link href="http://localhost:4000/2023/01/05/hongong9th.html" rel="alternate" type="text/html" title="혼공스터디9기 활동시작" /><published>2023-01-05T00:00:00+09:00</published><updated>2023-01-05T00:00:00+09:00</updated><id>http://localhost:4000/2023/01/05/hongong9th</id><content type="html" xml:base="http://localhost:4000/2023/01/05/hongong9th.html"><![CDATA[<h2 id="혼공스터디-9기-활동을-시작하다">혼공스터디 9기 활동을 시작하다</h2>

<p>2023년 새해가 시작되었습니다. 개발팀 내부 세미나를 올해에는 다양한 방식으로 진행해보고 싶었습니다.
그래서 1월과 2월은 IT서적 전문 출판사에서 주관하는 <혼공스터디>라는 프로그램에 참여해서 활동하는 방식으로
세미나를 진행하려고 합니다.</혼공스터디></p>

<p><img src="/img/posts/2023-01-05/hongong1.jpg" alt="혼공학습단" width="100%" /></p>

<p>혼공학습단 활동은 간단합니다. 도서를 선택하고, 학습스케줄에 맞춰서 6주동안 공부하고 미션을 수행한 내용을
SNS에 올려서 확인을 받으면 됩니다. 관련된 자세한 정보는 아래에 있는 페이스북 혼공스터디 그룹에 가시면 확인하실 수 있습니다.</p>

<p><strong><a href="https://www.facebook.com/groups/hongong/permalink/1185966548987467">페이스북 혼공스터디 그룹</a></strong>
https://www.facebook.com/groups/hongong/permalink/1185966548987467</p>

<hr />

<h2 id="혼자공부하는-데이터분석-with-파이썬">혼자공부하는 데이터분석 with 파이썬</h2>

<p>저희 개발팀이 혼공스터디 활동을 통해서 공부하려고 선택한 도서는 <code class="language-plaintext highlighter-rouge">혼자공부하는 데이터분석 with 파이썬</code>입니다.</p>

<p><img src="/img/posts/2023-01-05/hongong2.jpg" alt="혼자공부하는 데이터분석 with 파이썬" width="30%" /></p>

<p>사실 회사 생활하다보면 이런저런 핑계를 대면서 아무리 쉬운 내용이라도 책 한권을 온전히 읽어보면서
공부한다는게 쉬운 일은 아닐 것입니다. 특별한 노력이 뒷받침된다면 모르겠지만요. 혼공스터디 활동을 통해서 2023년 
시작부터 책 한권 공부를 끝낸다면 뿌듯하기도 할 것 같습니다.</p>

<p>아래는 저희가 활동할 혼공학습단9기의 학습스케줄입니다. 중도탈락하지 않고 모두 완주할 수 있도록 노력하겠습니다.</p>

<p><img src="/img/posts/2023-01-05/hongong3.png" alt="학습일정" width="100%" /></p>

<hr />

<h2 id="개발팀-세미나---혼공학습단-학습-내용-토의">개발팀 세미나 - 혼공학습단 학습 내용 토의</h2>

<p>개발팀 세미나는 혼공학습단 활동을 통해서 학습한 내용을 가지고 토의하는 시간이 될 것 같습니다. 이런 활동들 모두
블로그를 통해서 공개할 예정입니다.</p>

<p>감사합니다.</p>]]></content><author><name>이상훈</name></author><summary type="html"><![CDATA[혼공스터디 9기 활동을 시작하다]]></summary></entry><entry><title type="html">한해를 돌아보며…..</title><link href="http://localhost:4000/2022/12/22/self_reflection.html" rel="alternate" type="text/html" title="한해를 돌아보며….." /><published>2022-12-22T00:00:00+09:00</published><updated>2022-12-22T00:00:00+09:00</updated><id>http://localhost:4000/2022/12/22/self_reflection</id><content type="html" xml:base="http://localhost:4000/2022/12/22/self_reflection.html"><![CDATA[<p>아침에 출근해보니 책상 위에 2023년 다이어리가 놓여져 있는 것이 보였습니다. 
짧은 순간이기는 했지만, <code class="language-plaintext highlighter-rouge">올 한해도 벌써 다 지나갔구나</code>라는 아쉬움을 찐하게 마주할 수 있었습니다.</p>

<p><img src="/img/posts/2022-12-22/2023_diary.jpg" alt="2023년 다이어리" width="30%" class="left" /></p>

<p>돌이켜보면 2022년 우리 개발팀 팀원분들 모두 정말 바쁘게 열심히 살았던 것 같습니다. 물론, 죽어라 열심히 일만 하면서 살았던 
것은 아니겠지요. 적당히 분위기 보면서 게으름도 피우면서 지내기도 했습니다. 그렇지만, 집중해야 할 순간이 오면 자신이 가지고 있는
모든 역량을 쏟아 최선을 다하는 모습도 보였습니다. 그리고 실제로 좋은 성과들로 이어졌습니다.</p>

<p>클린팩토리 정부R&amp;D과제 수주, P사 ISDC DB서버 증설완료, P사 집진기 건전성 모니터링 시스템 준공 등등 올해 했던 많은 일들을 
자랑스럽게 생각하셔도 될 것 같습니다.</p>

<p>현재에 만족하지 않고 내년에도 계속 노력해주실 것이라 믿습니다. 내년에는 올해보다 더 즐겁게 일할 수 있는 환경을
만들어보겠습니다.</p>

<p><img src="/img/posts/2022-12-22/thanks.gif" alt="감사합니다." width="30%" class="left" /></p>]]></content><author><name>이상훈</name></author><summary type="html"><![CDATA[아침에 출근해보니 책상 위에 2023년 다이어리가 놓여져 있는 것이 보였습니다. 짧은 순간이기는 했지만, 올 한해도 벌써 다 지나갔구나라는 아쉬움을 찐하게 마주할 수 있었습니다.]]></summary></entry><entry><title type="html">GRAPHQL - 효율적인 데이터사용 웹서비스 아키텍처</title><link href="http://localhost:4000/2022/11/30/graphql.html" rel="alternate" type="text/html" title="GRAPHQL - 효율적인 데이터사용 웹서비스 아키텍처" /><published>2022-11-30T00:00:00+09:00</published><updated>2022-11-30T00:00:00+09:00</updated><id>http://localhost:4000/2022/11/30/graphql</id><content type="html" xml:base="http://localhost:4000/2022/11/30/graphql.html"><![CDATA[<p>안녕하세요. 에어릭스 개발팀 손민철입니다. 기존에 임베디드 분야에 몸을 담다가 이렇게 백엔드관련 지식을 습득하고 글을 쓰려고 하니 감회가 새롭습니다. 공부를 하면할 수록 기존에 안보이던 부분들이 이해가 되는 것이 참 기분이 좋습니다. 요번 Posting에서 작성할 내용은 GRAPHQL 아키텍처이고 기존에 산업에서 많이 사용되는 Rest api 아키텍처를 대체할 수 있는 웹서비스 아키텍처입니다. 어떠한 장,단점이 있고 어떻게 사용해야 하는 지 같이 보시죠.</p>

<hr />

<h2 id="graphql이란">GRAPHQL이란?</h2>

<p><img src="/img/posts/2022-11-30/facebook.png" alt="Facebook" width="100%" class="center" /></p>

<p>GRAPHQL이란 Facebook에서 2015년에 개발한 데이터 질의어로 웹서비스 아키텍처을 대체할 수 있습니다. 이에 대중적으로 사용되는 웹서비스 아키텍처인 rest api와 비교가 되고 rest api가 가지고 있는 overfetching, underfetching 문제(아래에서 다룰 예정)를 개선하였습니다.</p>

<p><img src="/img/posts/2022-11-30/graphql.png" alt="Graphql" width="100%" class="center" /></p>

<p><img src="/img/posts/2022-11-30/query.png" alt="query" width="100%" class="center" /></p>

<p>위 첫번째 사진은 GRAPHQL의 homepage Main에 있는 것을 캡처한 것으로 GRAPHQL의 동작을 단적으로 나타냅니다. 데이터타입을 작성하고(Describe) 데이터를 요청하고(Ask for) 적절한 대답을 응답받는 것(get predictable results)입니다. 두번째 사진에서는 직접 구현한 동작의 예시입니다. 원하는 데이터타입을 작성하고(Describe) 그에 상응하는 적절한 데이터 요청합니다.(Ask for) 그리고 response로 적절한 응답을 받습니다.(get predictable results)</p>

<h2 id="vs-rest-api">vs Rest API</h2>

<p>웹서비스 아키텍처로 많이 사용되는 Rest API에는 두가지 문제점이 있습니다. Overfetching, Underfetching인데 각 개념과 GRAPHQL에서 어떻게 개선되었는 지 보겠습니다.</p>

<ul>
  <li>overfetching</li>
</ul>

<p><img src="/img/posts/2022-11-30/overfetching.png" alt="overfetching" width="100%" class="center" /></p>

<p>Rest api에서는 하나의 url에 요청(Request)을 보내면 응답 전체를 무조건적으로 응답(Response)받아야 합니다. 즉, 불필요한 데이터까지 응답받아야 하기 때문에 필요이상으로 데이터 전송량이 늘어 납니다. GRAPHQL에서는 작성한 데이터타입 중에서도 필요한 데이터만 마치 SQL문에서 Query를 날리듯이 작성하면 필요한 데이터만 수집할 수 있습니다.</p>

<ul>
  <li>underfetching</li>
</ul>

<p><img src="/img/posts/2022-11-30/underfetching.png" alt="underfetching" width="100%" class="center" /></p>

<p>또한, Rest api에서는 여러 계층으로 나눠진 데이터들을 한 번에 요청하여 수집할 수 없습니다. 예를 들어, url:port/getdata1. url:port/getdata2 두 개의 계층의 데이터를 얻기 위해서는 각각 다른 요청을 보내야 합니다. 그런데 GRAPHQL에서는 하나의 query요청에 여러 계층을 포함하여 데이터 전송횟수를 감소시킬 수 있습니다.</p>

<p>하나 더, GRAPHQL은 하나의 endpoint만 이용합니다. 즉 url작성으로 시간을 낭비할 필요가 없습니다!!</p>

<h2 id="graphql-작성">GRAPHQL 작성</h2>

<p><img src="/img/posts/2022-11-30/apolo.png" alt="apolo" width="100%" class="center" /></p>

<p>자, 이제까지 GRAPHQL이란 무엇인가에 대해 살펴보았고 실제 GRAPHQL을 어떻게 사용하는 지 구현해보겠습니다. GRAPHQL도 REST API와 같이 개발자간의 명세,형식을 뿐입니다. 따라서 실제 이 규정에 맞에 데이터를 요청하고 응답할 수 있는 solution이 필요합니다. 저는 이번 예제에서 APOLO 솔루션을 사용할 예정입니다. javascript에 모듈형식으로 사용할 수 있어 쉽고 FRONT, BACK-END Solution을 전부 제공하기에 편리하여 이 솔루션을 선정하였습니다.</p>

<p><img src="/img/posts/2022-11-30/datatype.png" alt="datatype" width="100%" class="center" /></p>

<p><strong><code class="language-plaintext highlighter-rouge">describe your data</code></strong> : 데이터/요청 타입, 요청에 대한 Action을 작성합니다. Apolo server를 구동하기 위해서는 typeDefs, resolvers 인자가 필요합니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typeDefs : Graphql에 사용될 데이터, 요청타입을 작성합니다. 여기 요청타입이란 query, mutation 명세타입을 말하고 어떤 식으로 요청을 보낼 것인지를 결정합니다.
resolvers : 실제 Graphql요청이 왔을 때의 동작(Action)을 작성합니다.
</code></pre></div></div>

<p><img src="/img/posts/2022-11-30/query2.png" alt="query" width="100%" class="center" /></p>

<p><img src="/img/posts/2022-11-30/mutation.png" alt="mutation" width="100%" class="center" /></p>

<p><strong><code class="language-plaintext highlighter-rouge">ask for what you want &amp; get predictable results</code></strong> : 실제 데이터 요청(query, mutation)을 하고 적절한 응답을 받습니다.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>query : 원하는 데이터를 요청합니다.
mutation : 원하는 데이터를 삭제,수정,추가합니다.
</code></pre></div></div>

<p>간단히 어떻게 GRAPHQL 작성을 하는 지 살펴보았는데 더 구체적인 내용은 내용이 길어지는 관계로 다루지 않겠습니다.</p>

<h2 id="마치며">마치며</h2>
<p>실제 GRAPHQL로 구현을 해보니 데이터,요청 타입을 작성하는 과정이 생각보다 쉽지는 않았습니다. 이는 GRAPHQL에 단점이라고 생각합니다. 다만, 이런 처음 작성의 불편함에도 불구하고 데이터 전송량 감소, 데이터 요청 횟수 감소, 하나의 end-point로만 요청이라는 장점을 가지고 있어 매력적인 웹서비스 아키텍처라고 생각합니다. 또한 GRAPHQL기반 BACK-END개발자가 스키마 DOC을 FRONT개발자에게 제공한다면 특정데이터가 필요할 때 API를 새로 만드는 것이 아니라, 그에 맞게 Query를 요청하기만 하면 되서 업무적인 효율도 올라갈 것이라고 생각합니다. 다만 특정데이터를 항상 요청하고 응답받아야 한다면 오히려 Rest Api가 좋은 성능을 보입니다. 따라서 상황에 맞게 Rest API, GRAPHQL을 사용하는 것이 좋아보이고 추 후에 그 후기를 작성해보도록 하겠습니다.</p>]]></content><author><name>손민철</name></author><summary type="html"><![CDATA[안녕하세요. 에어릭스 개발팀 손민철입니다. 기존에 임베디드 분야에 몸을 담다가 이렇게 백엔드관련 지식을 습득하고 글을 쓰려고 하니 감회가 새롭습니다. 공부를 하면할 수록 기존에 안보이던 부분들이 이해가 되는 것이 참 기분이 좋습니다. 요번 Posting에서 작성할 내용은 GRAPHQL 아키텍처이고 기존에 산업에서 많이 사용되는 Rest api 아키텍처를 대체할 수 있는 웹서비스 아키텍처입니다. 어떠한 장,단점이 있고 어떻게 사용해야 하는 지 같이 보시죠.]]></summary></entry><entry><title type="html">Redis란?</title><link href="http://localhost:4000/2022/11/16/redis.html" rel="alternate" type="text/html" title="Redis란?" /><published>2022-11-16T00:00:00+09:00</published><updated>2022-11-16T00:00:00+09:00</updated><id>http://localhost:4000/2022/11/16/redis</id><content type="html" xml:base="http://localhost:4000/2022/11/16/redis.html"><![CDATA[<h1 id="redis란">Redis란?</h1>

<h2 id="목차">목차</h2>

<ol>
  <li>Redis란?</li>
  <li>Redis - NoSQL</li>
  <li>Redis - 영속성</li>
  <li>자료형과 기본적인 명령어들</li>
</ol>

<h2 id="redis란-1">Redis란?</h2>

<ol>
  <li>기본적으로 키-값의 형태로 데이터를 저장하는 데이터베이스입니다.</li>
  <li>메모리에 데이터가 저장되는 인메모리 데이터베이스로 빠른 응답속도를 가지며 동시에 주기적으로 데이터를 디스크에 저장함으로써 영속성을 보장하는 데이터베이스입니다.</li>
  <li>싱글 쓰레드로 작동하기 때문에 긴 트랜젝션이 들어오는 경우에는 그 요청을 처리하는 동안 다른 요청을 처리할 수 없다는 단점이 있으나 원자성을 자동적으로 보장해주는 장점이 있는 데이터베이스 입니다.</li>
</ol>

<p>종합적으로 Redis는 빠른 응답속도를 가지고 있으면서도 데이터를 영구적으로 NoSQL 방식으로 다양한 형식으로 저장할 수 있는 데이터베이스입니다.</p>

<h2 id="redis---nosql">Redis - NoSQL</h2>

<p>고정된 열과 행을 가지는 테이블을 이용하는 관계형 데이터베이스 모델을 따르지 않는 모든 데이터 베이스 모델을 의미합니다. 주로 사용되는 NoSQL의 종류로는 키-값 데이터베이스 모델, 와이어 컬럼 모델, 그래프 데이터베이스 모델이 있습니다.</p>

<h2 id="redis가-영속성을-보장하는-방법">Redis가 영속성을 보장하는 방법</h2>

<p>Redis는 인메모리 데이터베이스이지만 동시에 영속성을 보장하고 있습니다. 이러한 장점은 메모리에 저장되는 데이터를 주기적으로 DISK에 저장하는 형태로 이루어지며 저장하는 방식에 따라서 분류되는 RDB 방식과 AOF 방식을 사용하고 있습니다.</p>

<h3 id="rdb--방식">RDB  방식</h3>

<p>메모리의 스냅샷을 찍는 형태로 현재 메모리에 있는 정보를 그대로 디스크에 저장하고 불러오는 방식입니다. 메모리의 값을 그대로 사용하므로 불러오는 속도가 빠르며 크기가 작다는 장점이 있습니다. 반면에 백업이 진행되는 도중에 서버가 비정상적으로 종료되는 상황이 발생한다면 복원 지점의 데이터가 그대로 소실되는 단점이 있습니다.</p>

<h3 id="aof-방식">AOF 방식</h3>

<p>Redis에 일어난 쓰기/갱신 연산을 log에 저장하고 서버가 부팅되는 경우에 log에 기록된 연산을 다시 수행하는 방식입니다. 장점은 연산을 지속적으로 기록하기 때문에 서버가 비정상적으로 종료되더라도 데이터의 유실이 적으며 TEXT 형식으로 저장되기 떄문에 일어났던 연산을 수정하거나 확인하는 작업이 수월합니다. 단점은 로그를 모두 기록하므로 크기가 크며 불러오는 경우에는 일어났던 모든 연산을 다시 수행하여 최종 상태로 만들어야 하기 때문에 속도가 느립니다. 이때 AOF 방식의 경우 단점을 보완하기 위해서 로그를 연산을 수행한 특정 상태로 만드는 REWRITE 명령어가 있습니다.</p>

<p>RDB 방식과 AOF 방식, 그리고 관련된 설정은 Redis의 설정파일인 /etc/redis/redis.conf에서 확인하고 수정할 수 있습니다.</p>

<h2 id="redis에서-자주-사용되는-자료형과-명령어">Redis에서 자주 사용되는 자료형과 명령어</h2>

<h3 id="데이터베이스-명령어">데이터베이스 명령어</h3>

<p>SELECT : 데이터베이스를 설정하는 명령어이며 Redis의 경우 기본 값으로 16개의 데이터베이스를 지원하며 기본값으로 시작할 경우 0번째 데이터베이스로 시작합니다.</p>

<p>FLUSHDB : 데이터베이스의 모든 데이터를 제거하는 명령어 입니다.</p>

<h3 id="set">Set</h3>

<p>SET : 데이터베이스에 키, 값으로 저장</p>

<p>GET : 데이터베이스에서 키를 기반으로 데이터를 불러오기</p>

<p>DELETE : 데이터베이스에서 키를 기반으로 삭제</p>

<h3 id="list">List</h3>

<p>PUSH와 POP 연산을 기반으로 작동합니다.</p>

<p>LPUSH : 왼쪽으로 데이터를 추가</p>

<p>RPUSH : 오른쪽으로 데이터를 추가</p>

<p>LPOP : 왼쪽의 데이터를 가져오고 삭제</p>

<p>RPOP : 오른쪽의 데이터를 가져오고 삭제</p>

<p>LINSERT : 왼쪽을 기준으로 데이터 값을 저장</p>

<p>LSET : 왼쪽을 기준으로 데이터 값을 변경</p>

<p>LRANGE : 리스트 값을 조회</p>

<h3 id="sets-sorted-sets">Sets, Sorted sets</h3>

<p>SADD : 집합에 데이터를 추가</p>

<p>SMEMBERS : 집합의 데이터를 조회</p>

<p>SREM : 집합의 데이터를 삭제</p>

<h3 id="hashes">Hashes</h3>

<p>HSET : hashes에 데이터를 추가</p>

<p>HDEL : hashes의 데이터를 삭제</p>

<p>HGETALL : hashes의 데이터를 조회</p>

<h2 id="참조-사이트">참조 사이트</h2>

<p><a href="http://www.redisgate.com/redis/command/sets.php">http://www.redisgate.com/redis/command/sets.php</a></p>

<p><a href="https://ryu-e.tistory.com/m/9">https://ryu-e.tistory.com/m/9</a></p>

<p><a href="https://codingmania.tistory.com/m/25">https://codingmania.tistory.com/m/25</a></p>

<p><a href="https://redis.io/commands/">https://redis.io/commands/</a></p>

<p><a href="http://www.redisgate.com/redis/command/sets.php">http://www.redisgate.com/redis/command/</a></p>]]></content><author><name>강민구</name></author><summary type="html"><![CDATA[Redis란?]]></summary></entry><entry><title type="html">새로운 만남 - New Face from Viet Nam</title><link href="http://localhost:4000/2022/11/15/new_face.html" rel="alternate" type="text/html" title="새로운 만남 - New Face from Viet Nam" /><published>2022-11-15T00:00:00+09:00</published><updated>2022-11-15T00:00:00+09:00</updated><id>http://localhost:4000/2022/11/15/new_face</id><content type="html" xml:base="http://localhost:4000/2022/11/15/new_face.html"><![CDATA[<p>에어릭스 개발팀에 새로운 얼굴들이 나타났습니다. 바다 건너 베트남에서 온 개발자 Dang Quang Tuan(당꾸안투안, Lex)씨와 Ngo khanh Duy(응옥한유이, Tommy)씨를 환영합니다.</p>

<p>한국이 익숙하지않은 두 분을 위해 직접 인천공항으로 픽업을 나갔습니다. 영어에 유창하지만, 울렁증이 있다는 김영규 대리님을 위해, 의리 있는 제가 함께 공항으로 갔습니다.</p>

<p><img src="/img/posts/2022-11-15/nse-5502856638730671901-693.jpg" alt="panel" width="100%" class="center" /></p>

<p>준비성이 무척이나 철저한 모습입니다.</p>

<p><img src="/img/posts/2022-11-15/nse-1015362486945153275-691.jpg" alt="baseball" width="100%" class="center" /></p>

<p>입국 수속이 늦어지며 힘들어지던 때에 유명 야구선수 최지만 선수가 입국하는 모습도 보았습니다. 취재 열기가 장난이 아니었습니다.</p>

<p><del>사실 저와 김영규 대리님 둘 다 누구인지 몰라서 두리번거렸습니다…</del></p>

<p><img src="/img/posts/2022-11-15/nse-3466361857878663043-686.jpg" alt="chicken" width="100%" class="center" />
시간이 늦어진 만큼 재빠르게 이동해 저녁 식사를 함께했습니다. 원래 맛초킹을 시키려고 했는데, 매운 치킨을 강력히 주장하는 Lex씨 덕에 김영규 대리님은 매운맛에 고통받았습니다. 😆😆😆</p>

<p>손님 맞이한 두 명도 정신이 없어 많은 사진을 남기지 못한 것이 아쉽습니다. 앞으로 두 개발자분에 대한 더 많은 이야기를 남겨보겠습니다.
두 개발자 분의 활약을 응원해주세요!</p>]]></content><author><name>강민석</name></author><summary type="html"><![CDATA[에어릭스 개발팀에 새로운 얼굴들이 나타났습니다. 바다 건너 베트남에서 온 개발자 Dang Quang Tuan(당꾸안투안, Lex)씨와 Ngo khanh Duy(응옥한유이, Tommy)씨를 환영합니다.]]></summary></entry><entry><title type="html">전원 ON/OFF 반복 테스트 장치 개발구상</title><link href="http://localhost:4000/2022/11/15/power_test.html" rel="alternate" type="text/html" title="전원 ON/OFF 반복 테스트 장치 개발구상" /><published>2022-11-15T00:00:00+09:00</published><updated>2022-11-15T00:00:00+09:00</updated><id>http://localhost:4000/2022/11/15/power_test</id><content type="html" xml:base="http://localhost:4000/2022/11/15/power_test.html"><![CDATA[<p>에어릭스 개발팀장 이상훈입니다. 앞선 포스팅에서도 몇번 언급했던 것처럼 저희 제품의 품질향상을 위해서도 
여러가지 고민을 하고 있으며, 그에 따라서 다양한 시도를 해보고 있는 중입니다.</p>

<p><img src="/img/posts/tryitnow.png" alt="Try It Now" /></p>

<p>제 나름대로 최소한의 필요한 테스트 환경들을 갖춰보려고 하는 것도 그 시도의 일환이라고 볼 수 있겠습니다.
얼마전 오픈소스인 Apache JMeter를 활용해서 서버의 성능을 측정할 수 있는 테스트 환경을 구축해 놓았고,
이어서 디바이스에 전원을 반복적으로 ON/OFF해보면서 디바이스가 손상되지 않고 정상적으로 동작할 수 있는지 
확인해볼 수 있도록 테스트 환경구축을 구축해보고자 합니다.</p>

<hr />

<h2 id="릴레이모듈">릴레이모듈</h2>

<p>디바이스에 공급되고 있는 전원을 어떻게 내가 원하는대로 제어할 수 있을까? 방법을 몰라서 무작정 인터넷을 뒤적거리면서
찾아봤는데, 릴레이모듈이라는 부품을 사용하면 될 것 같습니다. 가격도 비싸지 않아서 바로 구입해버렸습니다. 
제가 구입한 릴레이모듈은 채널이 2개인 제품인데 아래 사진에 있는 제품입니다.</p>

<p><img src="/img/posts/relay.png" alt="2채널 릴레이모듈" /></p>

<p><img src="/img/posts/relay_pin.png" alt="릴레이모듈 PIN맵" width="100%" class="center" /></p>

<p>판매처 사이트(https://eduino.kr)에 릴레이모듈에 대해서 설명이 잘되어 있어서 아래에 첨부해봤습니다.</p>

<p><img src="/img/posts/relay_info.png" alt="릴레이모듈 설명" width="100%" class="center" /></p>

<hr />

<h2 id="라즈베리파이의-gpio-단자">라즈베리파이의 GPIO 단자</h2>

<p>릴레이모듈의 공통단자에 디바이스 전원의 GND를 연결하고, NO단자에 VCC선을 연결하면 제어신호 단자에 입력되는
신호를 통해서 원하는대로 전원 ON/OFF를 제어하는 것이 가능할 것 같습니다. 문제는 제어신호 단자에 어떻게
내가 원하는 신호를 줄 수 있느냐인데 이것도 라즈베리파이의 GPIO 단자를 통해서 해결하면 될 것 같습니다.</p>

<p>릴레이모듈의 제어신호 단자를 라즈베리파이의 GPIO 단자와 연결합니다. 그리고 라즈베리파이에서 GPIO 단자의 출력값을
변경하면서 전원 ON/OFF 테스트를 반복적으로 수행할 수 있도록 어플리케이션을 개발해서 구동시키면 됩니다.
단, 라즈베리파이의 GPIO 단자 출력이 DC 3.3V이기 때문에 릴레이모듈의 제어신호 단자에 그대로 연결할 수는 없습니다.
제어신호 단자에서는 DC 5V가 필요하기 때문입니다. 라즈베리파이의 GPIO단자와 릴레이모듈의 제어신호 단자 사이에 
전압증폭 회로가 필요할 것 같은데, 회사 하드웨어 팀에 도움을 받는다면 쉽게 해결할 수 있을 것 같습니다.</p>

<p><img src="/img/posts/raspberry.png" alt="라즈베리파이" /></p>

<hr />

<h2 id="디바이스의-정상동작-유무-판별">디바이스의 정상동작 유무 판별</h2>

<p>저희 디바이스들은 공통적으로 MQTT 프로토콜을 이용해서 데이터를 전송하는 기능을 가지고 있습니다.
MQTT 프로토콜을 통해서 데이터를 정상적으로 서버에 전송하고 있다면 일단은 해당 디바이스가 동작하고 있다고
볼 수 있을 것 같습니다. 물론 테스트 종료 이후에 육안으로 디바이스를 점검하면서 동작을 확인해보는 것도 필요해보이기는 합니다.</p>

<hr />

<h2 id="목표시스템">목표시스템</h2>

<p>결론적으로 목표했던 것처럼 전원 ON/OFF 반복 테스트가 가능한 환경을 위해서는 다음과 같은 구조로 장치를 구성해야 할 것 같습니다.</p>

<p><img src="/img/posts/arch.png" alt="구성도" width="100%" class="center" /></p>

<hr />

<h2 id="글을-마치며">글을 마치며</h2>

<p>이 글의 포스팅 때문에 저녁먹고 아이와 놀아주지 못해서 미안하기는 했지만, 그래도 머리속에 단순히 구상만 하고 있던 테스트 장치 개발에 대해서
생각을 조금 더 다듬고 구체화시킬 수 있었던 의미있는 시간이었던 것 같습니다.
주문한 릴레이모듈이 도착하면 팀원들과 함께 바로 장치 개발을 시작해볼 예정이고, 그 결과 또한 포스팅을 하도록 하겠습니다.</p>

<p>감사합니다.</p>]]></content><author><name>이상훈</name></author><summary type="html"><![CDATA[에어릭스 개발팀장 이상훈입니다. 앞선 포스팅에서도 몇번 언급했던 것처럼 저희 제품의 품질향상을 위해서도 여러가지 고민을 하고 있으며, 그에 따라서 다양한 시도를 해보고 있는 중입니다.]]></summary></entry><entry><title type="html">데이터 분석 - 개발팀 세미나</title><link href="http://localhost:4000/2022/10/28/data_semina.html" rel="alternate" type="text/html" title="데이터 분석 - 개발팀 세미나" /><published>2022-10-28T00:00:00+09:00</published><updated>2022-10-28T00:00:00+09:00</updated><id>http://localhost:4000/2022/10/28/data_semina</id><content type="html" xml:base="http://localhost:4000/2022/10/28/data_semina.html"><![CDATA[<p>안녕하세요. 에어릭스 환경시스템사업부의 개발팀 프론트엔드 개발자 송기영입니다.</p>

<p>오늘은 제가 진행했던 데이터 분석 세미나에 대해서 이야기를 해보려고 합니다.</p>

<h2 id="데이터-분석의-필요성">데이터 분석의 필요성</h2>

<p>현재 에어릭스 개발팀의 솔루션은 PLC나 블루투스 센서의 데이터들을 이용해 집진기의 상태를 제어 혹은 모니터링하는 시스템입니다. 하지만 수집된 데이터를 우리는 제대로 활용하지 못하고 있습니다.</p>

<p>현재 솔루션중 하나인 ISDC의 경우에도 3년치의 데이터를 쌓아두고 그저 지켜보고만 있습니다.</p>

<p align="center">
  <img src="/img/posts/2022-10-28/look.jpg" alt="look" width="70%" />
</p>

<p>저희 개발팀은 이 데이터를 어떻게 활용을 할 수 있을까를 생각해 보았고 데이터 활용을 하기 위해서는 데이터 분석이 무엇인지를 알아야 활용을 할 수 있다고 결론을 내리게 되었습니다.</p>

<h2 id="세미나-진행">세미나 진행</h2>

<p>세미나는 의견을 주고받으면서 약 1시간정도 진행되었지만 이 글에서는 최대한 간략하게 소개해보려고합니다.</p>

<p align="center">
  <img src="/img/posts/2022-10-28/1.jpeg" alt="semina_start" width="70%" />
</p>

<p align="center">
  <img src="/img/posts/2022-10-28/3.jpeg" alt="semina_start" width="70%" />
</p>

<p><a href="https://aerixdev.github.io/download/data_semina.pptx">교안 다운로드 : 데이터 분석 - 개발팀 세미나 자료.pptx</a></p>

<h3 id="데이터-분석이란">데이터 분석이란?</h3>

<p>사실 데이터 분석은 말 그래도 데이터를 분석하는 것입니다. 그리고 이 분석은 수학, 머신러닝, 컴퓨터사이언스, 통계연구, 데이터 처리, 도메인 전문서의 집합들의 지식이 있어야 비로소 데이터 분석의 기반이 됩니다.</p>

<p align="center">
  <img src="/img/posts/2022-10-28/data_science.png" alt="semina_start" width="70%" />
</p>

<p>데이터 분석의 핵심은 데이터 추출이 아닌 의사결정입니다.
이는 아래와 같이 정의할 수 있습니다.</p>
<ul>
  <li>수집한 데이터에서 어떤 가치를 뽑아내는가?</li>
  <li>데이터 분석을 해서 무엇을 얻고싶은가?</li>
  <li>데이터를 통한 올바른 의사결정을 할 수 있는가?</li>
</ul>

<p>이러한 의사결정들을 통해 추출된 데이터를 어떻게 활용하는지는 데이터를 사용하는 사용자에 따라 결정됩니다.</p>

<h3 id="데이터-분석-툴">데이터 분석 툴?</h3>

<p>데이터 분석을 위해서는 파이썬, R, 엑셀, SQL, 태블로, Power BI, 구글애널리틱스 등 다양한 방법이 있습니다. 이중에 저는 가장 많이 사용되는 파이썬과 R을 비교해보았습니다. 아래의 표와 같은 이유로 저는 <strong><code class="language-plaintext highlighter-rouge">개발자</code></strong>이기 때문에 파이썬을 이용해 데이터를 분석해보았습니다.</p>

<p align="center">
  <img src="/img/posts/2022-10-28/tool.png" alt="semina_start" width="70%" />
</p>

<h3 id="데이터-분석-과정">데이터 분석 과정</h3>
<p>데이터 분석과정은 수집, 탐색, 시각화, 목적으로 진행됩니다.</p>
<ul>
  <li><strong>수집</strong> : 데이터를 수집하는 단계</li>
  <li><strong>탐색</strong> : 로우 데이터에서 인사이트를 발견</li>
  <li><strong>시각화</strong> : 탐색을 통해 발견된 내용을 시각화</li>
  <li><strong>목적</strong> : 데이터를 분석하는 목적</li>
</ul>

<p>그리고 탐색부터 목적까지는 계속 반복됩니다. 예로 하나의 데이터 셋에서 한가지의 목적을 찾는 것이 아닌 데이터 분석을 반복하면서 구체화된 목적을 찾을수 있으니까요.</p>

<h3 id="실-데이터-분석">실 데이터 분석</h3>
<p>세미나에서는 다양한 자료들로 데이터를 분석하였지만 이 글에서는 저희회사의 진동센서 데이터를 가지고 데이터 분석 예를 이야기해보겠습니다.</p>

<ul>
  <li>
    <p><strong>탐색</strong>
수집된 데이터를 보고 다음과 같은 인사이트를 찾을 수 있습니다.</p>

    <ul>
      <li>X값이 클때 Y값도 클까?</li>
      <li>진동이 발생했을때 X와 Y가 모두 값이 클까?</li>
      <li>특정시간에 진동이 쎄지고 약해질까?</li>
    </ul>
  </li>
</ul>

<p align="center">
  <img src="/img/posts/2022-10-28/find.png" alt="semina_start" width="70%" />
</p>

<ul>
  <li><strong>시각화</strong>
수집된 데이터를 가지고 시각화를 하면 아래와 같이 생성됩니다. 인사이트된 데이터를 시각화를 한것이 아닌 단순히 수집된 데이터를 시각화 했습니다.</li>
</ul>

<p align="center">
  <img src="/img/posts/2022-10-28/graph.png" alt="semina_start" width="70%" />
</p>

<ul>
  <li><strong>목적</strong>
시각화된 데이터를 가지고 우리는 특정 시간에 x,y,z 값이 비정상적인 것을 확인 할 수 있습니다. 이를 통해 저 시간대에는 어떤 이슈가 발생했었는지를 파악할 수 있고 우리는 이를 해결하기 위한 방향성을 정할 수 있게됩니다.</li>
</ul>

<h3 id="데이터-검정">데이터 검정</h3>
<p>데이터를 뽑아왔는데 어떤 정보를 신뢰할 수 있을까라는 의심이 생깁니다.
지금까지는 그림을 보거나 평균값을 통해 데이터를 검정했습니다. 하지만 데이터 분석에서는 이를 정밀하게 검증할 수 있으면 검증을 진행합니다. 대표적인 예로 T-TEST
가 있습니다.</p>

<h4 id="t-test-란">T-TEST 란?</h4>
<p>두 집단간의 평균의 차이에 대한 검정 방법으로
귀무가설과 대립가설 중 하나를 선택하는 검정방법입니다.</p>

<p align="center">
  <img src="/img/posts/2022-10-28/test.png" alt="semina_start" width="70%" />
</p>

<p>여기서 귀무가설은 버려질 것으로 예상되는 가설로, t-test 이후에 가설을 수용할지 기각할지를 결정합니다.</p>

<h3 id="데이터-검정-예시">데이터 검정 예시</h3>

<p>진동센서 X값과 Y값 차이 검정 예시(귀무가설)</p>
<p align="center">
  <img src="/img/posts/2022-10-28/test-result1.png" alt="semina_start" width="70%" />
</p>

<p>진동센서 X값과 Z값 차이 검정 예시(대립가설)</p>
<p align="center">
  <img src="/img/posts/2022-10-28/test-result2.png" alt="semina_start" width="70%" />
</p>

<p>T-TEST를 통한 p-value 값이 0에 가까우면 귀무가설 기준값 0.5보다 크면 대립가설이 됩니다.</p>

<p>여기서의 기준값은 평균적으로 0.5를 기준으로 하며 데이터에 따라 기준값이 변동됩니다.</p>

<h3 id="질문">질문</h3>

<p>세미나 후에 다양한 질문과 토론들이 있었습니다. 예를 들어 분석된 데이터를 통해 어떤식으로 우리는 활용할 수 있을지에 대한 내용이 있었고 현재 ISDC 솔루션의 데이터를 활용할 수 있는 방안 등에 대한 내용들에 관한 내용이 오갔습니다.</p>

<p align="center">
  <img src="/img/posts/2022-10-28/2.jpeg" alt="semina_start" width="60%" />
</p>

<h3 id="마치며">마치며</h3>

<p>저는 이번 세미나를 통해 데이터 분석에 대한 제 나름대로 결론을 내렸습니다.</p>

<ol>
  <li>
    <p>데이터 분석은 탐색된 데이터를 바탕으로 특정 데이터의 <strong><code class="language-plaintext highlighter-rouge">가치</code></strong>를 찾는 과정이다.</p>
  </li>
  <li>
    <p>데이터 분석은 탐색, 시각화, 목적을 계속 반복하면서 <strong><code class="language-plaintext highlighter-rouge">구체화된 방향성과 결론</code></strong>을 도출하는 것이다.</p>
  </li>
  <li>
    <p>인사이트는 데이터 분석가의 생각과 데이터의 형태에 따라 유연하게 도출된다.</p>
  </li>
  <li>
    <p>데이터 분석은 <strong><code class="language-plaintext highlighter-rouge">이윤</code></strong>을 창출하기 위함이다.</p>
  </li>
</ol>

<p>블로그 글을 작성하면서 이번만큼 어려웠던적이 없었던것 같습니다. 최대한 쉽게 설명하려고 노력했는데 이해되지 않는 부분이 있으시면 질문 남겨주시면 답변드리겠습니다.</p>

<p>부족하지만 긴 글 읽어주셔서 감사합니다.</p>]]></content><author><name>송기영</name></author><summary type="html"><![CDATA[안녕하세요. 에어릭스 환경시스템사업부의 개발팀 프론트엔드 개발자 송기영입니다.]]></summary></entry><entry><title type="html">웹 취약점 분석과 해킹 대응 - 개발팀 세미나</title><link href="http://localhost:4000/2022/10/13/security_semina-copy.html" rel="alternate" type="text/html" title="웹 취약점 분석과 해킹 대응 - 개발팀 세미나" /><published>2022-10-13T00:00:00+09:00</published><updated>2022-10-13T00:00:00+09:00</updated><id>http://localhost:4000/2022/10/13/security_semina%20copy</id><content type="html" xml:base="http://localhost:4000/2022/10/13/security_semina-copy.html"><![CDATA[<h3 id="0-개발팀-세미나">0. 개발팀 세미나</h3>

<p>개발팀 인원들 모두 맡은 업무에 성실하면서도 자기 개발에 힘쓰고 있습니다. 하지만 새로이 습득한 지식과 기술들이 팀원들과 공유되지 않아, 활용되지 못하고 개인의 것으로 남아있거나 소실 경우가 많은 것이 사실입니다. 이에 우리 에어릭스 개발팀에서는 내부 세미나를 열어 서로가 얻은 기술을 공유하고 의견을 나눔을 통해 실제 개발에 적용될 수 있도록 하고있습니다.</p>

<h3 id="1-주제--웹-취약점-분석과-해킹-대응---22년-10월-13일">1. 주제 : 웹 취약점 분석과 해킹 대응 - 22년 10월 13일</h3>

<p><img src="/img/posts/2022-10-13/security_semina.jpg" alt="security_semina" /></p>

<p><a href="https://aerixdev.github.io/download/security_semina.pptx">교안 다운로드 : 웹 취약점 분석과 해킹 대응 - 개발팀 세미나 자료.pptx</a></p>

<p>여태까지 우리 개발팀의 방향은 기능에 충실하고 에러, 버그가 없는 제품을 만드는 것을 중점으로 하고있었습니다. 보안에 있어서는 중요하다는 생각은 가지고 있지만, 취약점 사례들을 알 지 못하고 실제로 어떤 피해로 다가올 수 있는지 체감하지 못하고 있었던 실정이라 크게 신경 쓰지 못하고 있는 상황입니다. 이번 세미나를 통해 웹 보안의 주요 취약점 사례들과 대처 방법을 알아보면서 보안에 대한 관심을 환기할 수 있는 시간을 가져보았습니다.</p>

<h3 id="2-세미나-진행">2. 세미나 진행</h3>

<p>이번 세미나는 웹 보안을 위한 툴들의 기초 사용법과 주요 취약점 사례들에 대해 알아보는 것이 주요 내용이었습니다.</p>

<p><img src="/img/posts/2022-10-13/owasp_zap.png" alt="owasp_zap" /></p>

<p>웹 보안 스캐너 OWASP-ZAP(Zed Attack Proxy)을 통한 웹페이지 취약점을 분석법에 대해 알아보았습니다. Spider, 강제 검색 등의 기법으로 웹페이지에서 사용자에게 공개되지 않은 페이지들이 손쉽게 노출될 수 있는 상황에 대해 알아보았습니다.</p>

<p><img src="/img/posts/2022-10-13/sql_injection.png" alt="sql_injection" /></p>

<p>또한 주요 취약점으로 경로 탐색 취약점, SQL 인젝션, 크로스 사이트 스크립팅(XSS) 사례를 알아보고 그에 대처법을 공유했습니다. 이 중 SQL 인젝션이 우리 개발에 있어 가장 취약한 부분이며 대처하기도 쉽지 않은 부분이었습니다. 기본적인 SQL 인젝션에 대한 대비부터 먼저 실시하고, 고도의 인젝션 공격들에 대해서는 앞으로 개발자로서 발전하면서 끊임없이 싸워야 할 부분이라는 것을 체감했습니다.</p>

<p><img src="/img/posts/2022-10-13/security_onion.png" alt="security_onion" /></p>

<p>마지막 순서로 NSM(Network Security Monitoring) 도구인 Security Onion에 대해 알아보았습니다. 앞서 SQL 인젝션 상황과 같이 개발을 하면서 모든 취약점에 대해 대비할 수 는 없기 때문에 필요한 것이 NSM입니다. 제품 운영 단계에서 실시간으로 공격을 감지하고 이에 대해 적절한 대처를 하도록 도와줍니다. 제품 출시 후 NSM을 통한 중앙 관제를 도입하는 것도 좋은 방안이 될 수 있겠습니다.</p>

<h3 id="3-마치며">3. 마치며</h3>

<p>이번 세미나를 통해 웹 보안에 대한 깊은 지식을 가졌다고 보긴 힘들 것 같습니다. 하지만 보안에 대한 관심을 환기하고 앞으로 과업에 대한 마음가짐을 가지는 데에는 충분한 시간이었습니다.  실제로 쿼리문 작성에도 더 신경을 쓰게 되고, 보안 자동화 관련 API 도입에도 관심을 가지게 되었습니다. 우리 개발 팀 모두 한걸음 나아가는 시간이 되었던 것 같습니다.</p>]]></content><author><name>강민석</name></author><summary type="html"><![CDATA[0. 개발팀 세미나]]></summary></entry></feed>